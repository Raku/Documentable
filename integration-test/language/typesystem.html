<!doctype html>
<html lang="en">
<head>
    <title>Type system</title>
    <meta charset="UTF-8"/>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel="icon" href="/Documentable/integration-test/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="/Documentable/integration-test/css/app.css" media="screen" title="default" />
    <noscript> <style> #search { visibility: hidden; } </style> </noscript>
</head>

<body class="pod">

    <div id="___top"></div>

    <div id="header" class="pretty-box green">

        <a href="/Documentable/integration-test/">
            <img src="/Documentable/integration-test/images/Camelia.svg"alt="»ö«"id="logo"width="62"height="48"/> &nbsp;Raku Documentation
        </a>

        <div id="search" class="ui-widget">
            <div class="green">
                <input placeholder="Loading..." id="query" accesskey="f" title="Enter term to search for (hit Esc to focus)"/>
            </div>
            <p id="not-found-message">
                Not in Index (<a href="" id="try-web-search">try site search</a>)
            </p>
        </div>
        
        <div class="menu">
            
            <div class="menu-items dark-green">
                <a class='menu-item darker-green' href='https://raku.org'><strong>Raku homepage</strong></a>
                    <a class="menu-item selected darker-green" href="/Documentable/integration-test/language.html"> Language </a>
                    <a class="menu-item " href="/Documentable/integration-test/type.html"> Types </a>
                    <a class="menu-item " href="/Documentable/integration-test/routine.html"> Routines </a>
                    <a class="menu-item " href="/Documentable/integration-test/programs.html"> Programs </a>
                    <a class="menu-item " href="https://webchat.freenode.net/?channels=#raku"> Chat with us </a>
            </div>
            
            
            
        
        </div>
    </div>

    <div id="content" class="pretty-box yellow content_fragment">

        <div align="right" style="display:;">
            <button title="Edit this page"  class="pencil" onclick="location='https://github.com/Raku/doc/edit/master/doc/Language/typesystem.pod6'">
                <svg width="14px" height="16px" viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <defs></defs>
                    <g id="Octicons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="pencil" fill="#000000">
                            <path d="M0,12 L0,15 L3,15 L11,7 L8,4 L0,12 L0,12 Z M3,14 L1,14 L1,12 L2,12 L2,13 L3,13 L3,14 L3,14 Z M13.3,4.7 L12,6 L9,3 L10.3,1.7 C10.69,1.31 11.32,1.31 11.71,1.7 L13.3,3.29 C13.69,3.68 13.69,4.31 13.3,4.7 L13.3,4.7 Z" id="Shape"></path>
                        </g>
                    </g>
                </svg>
            </button>
        </div>

        <h1 class="title">Type system</h1>
        <p class="subtitle">Introduction to the type system of Raku</p>

        <nav class="indexgroup">
<table id="TOC">
<caption><h2 id="TOC_Title">Table of Contents</h2></caption>
  <tr class="toc-level-1"><td class="toc-number">1</td><td class="toc-text"><a href="#Definition_of_a_Raku_type">Definition of a Raku type</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">1.1</td><td class="toc-text"><a href="#Default_types">Default types</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">1.2</td><td class="toc-text"><a href="#Type_objects">Type objects</a></td></tr>
                        <tr class="toc-level-3"><td class="toc-number">1.2.1</td><td class="toc-text"><a href="#Undefinedness">Undefinedness</a></td></tr>
                                          <tr class="toc-level-3"><td class="toc-number">1.2.2</td><td class="toc-text"><a href="#Coercion">Coercion</a></td></tr>
               <tr class="toc-level-1"><td class="toc-number">2</td><td class="toc-text"><a href="#Type_declarators">Type declarators</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">2.1</td><td class="toc-text"><a href="#class"><code class="pod-code-inline">class</code></a></td></tr>
                 <tr class="toc-level-3"><td class="toc-number">2.1.1</td><td class="toc-text"><a href="#Mixins">Mixins</a></td></tr>
       <tr class="toc-level-3"><td class="toc-number">2.1.2</td><td class="toc-text"><a href="#Introspection">Introspection</a></td></tr>
 <tr class="toc-level-4"><td class="toc-number">2.1.2.1</td><td class="toc-text"><a href="#Metaclass">Metaclass</a></td></tr>
       <tr class="toc-level-3"><td class="toc-number">2.1.3</td><td class="toc-text"><a href="#Private_attributes">Private attributes</a></td></tr>
            <tr class="toc-level-3"><td class="toc-number">2.1.4</td><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
            <tr class="toc-level-4"><td class="toc-number">2.1.4.1</td><td class="toc-text"><a href="#Inheritance_and_multis">Inheritance and multis</a></td></tr>
    <tr class="toc-level-4"><td class="toc-number">2.1.4.2</td><td class="toc-text"><a href="#Only_method">Only method</a></td></tr>
              <tr class="toc-level-4"><td class="toc-number">2.1.4.3</td><td class="toc-text"><a href="#submethod_BUILD">submethod BUILD</a></td></tr>
                 <tr class="toc-level-4"><td class="toc-number">2.1.4.4</td><td class="toc-text"><a href="#Fallback_method">Fallback method </a></td></tr>
            <tr class="toc-level-4"><td class="toc-number">2.1.4.5</td><td class="toc-text"><a href="#Reserved_method_names">Reserved method names</a></td></tr>
                     <tr class="toc-level-4"><td class="toc-number">2.1.4.6</td><td class="toc-text"><a href="#Methods_in_package_scope">Methods in package scope</a></td></tr>
     <tr class="toc-level-4"><td class="toc-number">2.1.4.7</td><td class="toc-text"><a href="#Setting_attributes_with_namesake_variables_and_methods">Setting attributes with namesake variables and methods</a></td></tr>
                    <tr class="toc-level-3"><td class="toc-number">2.1.5</td><td class="toc-text"><a href="#trait_is_nodal">trait <code class="pod-code-inline">is nodal</code></a></td></tr>
                <tr class="toc-level-3"><td class="toc-number">2.1.6</td><td class="toc-text"><a href="#trait_handles">trait <code class="pod-code-inline">handles</code></a></td></tr>
                       <tr class="toc-level-3"><td class="toc-number">2.1.7</td><td class="toc-text"><a href="#trait_is">trait <code class="pod-code-inline">is</code></a></td></tr>
              <tr class="toc-level-3"><td class="toc-number">2.1.8</td><td class="toc-text"><a href="#trait_is_rw">trait <code class="pod-code-inline">is rw</code></a></td></tr>
         <tr class="toc-level-3"><td class="toc-number">2.1.9</td><td class="toc-text"><a href="#trait_is_required">trait <code class="pod-code-inline">is required</code></a></td></tr>
                   <tr class="toc-level-3"><td class="toc-number">2.1.10</td><td class="toc-text"><a href="#trait_hides">trait <code class="pod-code-inline">hides</code></a></td></tr>
             <tr class="toc-level-3"><td class="toc-number">2.1.11</td><td class="toc-text"><a href="#trait_trusts">trait <code class="pod-code-inline">trusts</code></a></td></tr>
     <tr class="toc-level-3"><td class="toc-number">2.1.12</td><td class="toc-text"><a href="#Augmenting_a_class">Augmenting a class</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">2.2</td><td class="toc-text"><a href="#role"><code class="pod-code-inline">role</code></a></td></tr>
              <tr class="toc-level-3"><td class="toc-number">2.2.1</td><td class="toc-text"><a href="#Auto-punning">Auto-punning</a></td></tr>
   <tr class="toc-level-3"><td class="toc-number">2.2.2</td><td class="toc-text"><a href="#trait_does">trait <code class="pod-code-inline">does</code></a></td></tr>
          <tr class="toc-level-3"><td class="toc-number">2.2.3</td><td class="toc-text"><a href="#Parameterized">Parameterized</a></td></tr>
                 <tr class="toc-level-3"><td class="toc-number">2.2.4</td><td class="toc-text"><a href="#As_type_constraints">As type constraints</a></td></tr>
                                                                   <tr class="toc-level-2"><td class="toc-number">2.3</td><td class="toc-text"><a href="#enum"><code class="pod-code-inline">enum</code></a></td></tr>
                                                                                <tr class="toc-level-3"><td class="toc-number">2.3.1</td><td class="toc-text"><a href="#Typing_Enums">Typing Enums</a></td></tr>
                                                <tr class="toc-level-3"><td class="toc-number">2.3.2</td><td class="toc-text"><a href="#Metaclass">Metaclass</a></td></tr>
           <tr class="toc-level-3"><td class="toc-number">2.3.3</td><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-4"><td class="toc-number">2.3.3.1</td><td class="toc-text"><a href="#method_enums">method enums</a></td></tr>
     <tr class="toc-level-3"><td class="toc-number">2.3.4</td><td class="toc-text"><a href="#Coercion">Coercion</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">2.4</td><td class="toc-text"><a href="#module"><code class="pod-code-inline">module</code></a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">2.5</td><td class="toc-text"><a href="#package"><code class="pod-code-inline">package</code></a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">2.6</td><td class="toc-text"><a href="#grammar"><code class="pod-code-inline">grammar</code></a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">2.7</td><td class="toc-text"><a href="#subset"><code class="pod-code-inline">subset</code></a></td></tr>
                      <tr class="toc-level-1"><td class="toc-number">3</td><td class="toc-text"><a href="#Versioning,_authorship,_and_API_version.">Versioning, authorship, and API version.</a></td></tr>
                                          
</table>
</nav>

        <div class="pod-body ">
            <h1 id="Definition_of_a_Raku_type"><a class="u" href="#___top" title="go to top of document">Definition of a Raku type</a></h1>
<p>A type defines a new object by creating a type object that provides an interface to create instances of objects or to check values against. Any type object is a subclass of <a href="/Documentable/integration-test/type/Any">Any</a> or <a href="/Documentable/integration-test/type/Mu">Mu</a>. Introspection methods are provided via inheritance from those base classes and the introspection postfix <a href="/Documentable/integration-test/language/operators#postfix_.$CIRCUMFLEX_ACCENT">.^</a>. A new type is introduced to the current scope by one of the following type declarators at compile time or with the <a href="/Documentable/integration-test/language/mop">metaobject protocol</a> at runtime. All type names must be unique in their scope.</p>
<h2 id="Default_types"><a class="u" href="#___top" title="go to top of document">Default types</a></h2>
<p>If no type is provided by the user Raku assumes the type to be <code>Any</code>. This includes <a href="/Documentable/integration-test/language/containers">containers</a>, base-classes, <a href="/Documentable/integration-test/type/Signature#Type_constraints">parameters</a> and return types.</p>
<pre class="pod-block-code">my $a = 1;
$a = Nil;
say $a.^name;
# OUTPUT: «Any␤»

class C {};
say C.^parents(:all);
# OUTPUT: «((Any) (Mu))␤»</pre>
<p>For containers the default type is <code>Any</code> but the default type constraint is <code>Mu</code>. Please note that binding replaces the container, not just the value. The type constraint may change in this case.</p>
<h2 id="Type_objects"><a class="u" href="#___top" title="go to top of document">Type objects</a></h2>
<p>To test if an object is a type object, use <a href="/Documentable/integration-test/language/operators#index-entry-smartmatch_operator">smartmatch</a> against a type constrained with a <a href="/Documentable/integration-test/type/Signature#Constraining_defined_and_undefined_values">type smiley</a> or <a href="/Documentable/integration-test/language/mop#index-entry-syntax_DEFINITE-DEFINITE"><code>.DEFINITE</code></a> method:</p>
<pre class="pod-block-code">my $a = Int;
say $a ~~ Mu:U;
# OUTPUT: «True␤»
say not $a.DEFINITE;
# OUTPUT: «True␤»
</pre>
<p><code>.DEFINITE</code> will return <code>True</code> if the invocant is an instance. If it returns <code>False</code>, then the invocant is a type object.</p>
<h3 id="Undefinedness"><a class="u" href="#___top" title="go to top of document">Undefinedness</a></h3>
<p>Undefined objects maintain type information in Raku. Type objects are used to represent both undefinedness and the type of the undefined value. To provide a general undefined value use <a href="/Documentable/integration-test/type/Any">Any</a>. If differentiation from <code>Any</code>, the default type for containers and arguments, is required use <a href="/Documentable/integration-test/type/Mu">Mu</a>.</p>
<p>Instances of objects created by <a href="/Documentable/integration-test/type/Mu#method_CREATE">.CREATE</a> are by convention defined. The method <a href="/Documentable/integration-test/type/Mu#routine_defined">.defined</a> will return <code>Bool::True</code> to indicate definedness. The exceptions to that rule are <a href="/Documentable/integration-test/type/Nil">Nil</a> and <a href="/Documentable/integration-test/type/Failure">Failure</a>. Please note that any object is able to overload <code>.defined</code> and as such can carry additional information. Also, Raku makes a clear distinction between definedness and trueness. Many values are defined even though they carry the meaning of wrongness or emptiness. Such values are <code>0</code>, <a href="/Documentable/integration-test/type/Bool">Bool::False</a>, <a href="/Documentable/integration-test/language/operators#term_(_)">()</a> (empty list) and <a href="/Documentable/integration-test/type/Num#NaN">NaN</a>.</p>
<p>Values can become undefined at runtime via <a href="/Documentable/integration-test/language/operators#infix_but">mixin</a>.</p>
<pre class="pod-block-code">my Int $i = 1 but role :: { method defined { False } };
say $i // &quot;undefined&quot;;
# OUTPUT: «undefined␤»</pre>
<p>To test for definedness call <code>.defined</code>, use <a href="/Documentable/integration-test/language/operators#infix_//">//</a>, <a href="/Documentable/integration-test/language/control#with,_orwith,_without">with/without</a> and <a href="/Documentable/integration-test/type/Signature#Constraining_defined_and_undefined_values">signatures</a>.</p>
<h3 id="Coercion"><a class="u" href="#___top" title="go to top of document">Coercion</a></h3>
<p>Turning one type into another is done with coercion methods that have the same name as the target type. This convention is made mandatory by <a href="/Documentable/integration-test/type/Signature#Coercion_type">Signatures</a>. The source type has to know how to turn itself into the target type. To allow built-in types to turn themselves into user defined types use <a href="/Documentable/integration-test/language/variables#The_augment_declarator">augment</a> or the <a href="/Documentable/integration-test/language/mop">MOP</a>.</p>
<pre class="pod-block-code">class C {
    has $.int;
    method this-is-c { put &#39;oi&#39; x $!int ~ &#39;‽&#39; }
}

use MONKEY-TYPING;
augment class Int {
    method C { C.new(:int(self))}
}

my $i = 10;
$i.=C;
$i.this-is-c();
# OUTPUT: «oioioioioioioioioioi‽␤»</pre>
<p>Raku provides methods defined in <a href="/Documentable/integration-test/type/Cool">Cool</a> to convert to a target type before applying further operations. Most built-in types descend from <code>Cool</code> and as such may provide implicit coercion that may be undesired. It is the responsibility of the user to care about trap-free usage of those methods.</p>
<pre class="pod-block-code">my $whatever = &quot;123.6&quot;;
say $whatever.round;
# OUTPUT: «124␤»
say &lt;a b c d&gt;.starts-with(&quot;ab&quot;);
# OUTPUT: «False␤»</pre>
<h1 id="Type_declarators"><a class="u" href="#___top" title="go to top of document">Type declarators</a></h1>
<p>Type declarators introduce a new type into the given scope. Nested scopes can be separated by <code>::</code>. New <a href="/Documentable/integration-test/language/packages">packages</a> are created automatically if no such scope exists already.</p>
<pre class="pod-block-code">class Foo::Bar::C {};
put Foo::Bar::.keys;
# OUTPUT: «C␤»</pre>
<p><a name="Documentable/integration-test/index-entry-..._(forward_declaration)"></a> <a name="Documentable/integration-test/index-entry-Forward_declarations"><span class="index-entry">Forward declarations</span></a> can be provided with a block containing only <code>...</code>. The compiler will check at the end of the current scope if the type is defined.</p>
<pre class="pod-block-code">class C {...}
# many lines later
class C { has $.attr }</pre>
<h2 id="class"><a class="u" href="#___top" title="go to top of document"><code>class</code></a></h2>
<p>The <code>class</code> declarator creates a compile time construct that is compiled into a type object. The latter is a simple Raku object and provides methods to construct instances by executing initializers and sub methods to fill all attributes declared in a class, and any parent class, with values. Initializers can be provided with the declaration of attributes or in constructors. It&#39;s the responsibility of the <a href="/Documentable/integration-test/type/Metamodel::ClassHOW">Metamodel::ClassHOW</a> to know how to run them. This is the only magic part of building objects in Raku. The default parent type is <code>Any</code>, which in turn inherits from <code>Mu</code>. The latter provides the default constructor <code>.new</code> which is named like this by convention. Aside from this, <code>.new</code> does not carry any special meaning nor is treated in any special way.</p>
<p>For more information how to use classes see the <a href="/Documentable/integration-test/language/classtut">Classes and objects</a> tutorial.</p>
<h3 id="Mixins"><a class="u" href="#___top" title="go to top of document">Mixins</a></h3>
<p>The type introduced by <code>class</code> can be extended with <a href="/Documentable/integration-test/language/operators#infix_but">infix:&lt;but&gt;</a> at runtime. The original type is not modified, instead a new type object is returned and can be stored in a container that type checks successful against the original type or the role that is mixed in.</p>
<pre class="pod-block-code">class A {}
role R { method m { say &#39;oi‽&#39; } }
my R $A = A but R;
my $a1 = $A.new;
$a1.m;
say [$A ~~ R, $a1 ~~ R];
# OUTPUT: «oi‽␤[True True]␤»</pre>
<h3 id="Introspection"><a class="u" href="#___top" title="go to top of document">Introspection</a></h3>
<h4 id="Metaclass"><a class="u" href="#___top" title="go to top of document">Metaclass</a></h4>
<p>To test if a given type object is a class, test the metaobject method <code>.HOW</code> against <a href="/Documentable/integration-test/type/Metamodel::ClassHOW">Metamodel::ClassHOW</a>.</p>
<pre class="pod-block-code">class C {};
say C.HOW ~~ Metamodel::ClassHOW;
# OUTPUT: «True␤»</pre>
<h3 id="Private_attributes"><a class="u" href="#___top" title="go to top of document">Private attributes</a></h3>
<p>Private <a href="/Documentable/integration-test/type/Attribute">attribute</a>s are addressed with any of the twigils <code>$!</code>, <code>@!</code> and <code>%!</code>. They do not have public accessor methods generated automatically. As such they can not be altered from outside the class they are defined in.</p>
<pre class="pod-block-code">class C {
    has $!priv;
    submethod BUILD { $!priv = 42 }
};

say (.name, .package, .has_accessor) for C.new.^attributes;
# OUTPUT: «($!priv (C) False)␤»</pre>
<p><a name="Documentable/integration-test/index-entry-method_(declarator)"></a></p>
<h3 id="Methods"><a class="u" href="#___top" title="go to top of document">Methods</a></h3>
<p>The <code>method</code> declarator defines objects of type <a href="/Documentable/integration-test/type/Method">Method</a> and binds them to the provided name in the scope of a class. Methods in a class are <code>has</code> scoped by default. Methods that are <code>our</code> scoped are not added to the method cache by default and as such can not be called with the accessor sigil <code>$.</code>. Call them with their fully qualified name and the invocant as the first argument.</p>
<h4 id="Inheritance_and_multis"><a class="u" href="#___top" title="go to top of document">Inheritance and multis</a></h4>
<p>A normal method in a subclass does not compete with multis of a parent class.</p>
<pre class="pod-block-code">class A {
    multi method m(Int $i){ say &#39;Int&#39; }
    multi method m(int $i){ say &#39;int&#39; }
}

class B is A {
    method m(Int $i){ say &#39;B::Int&#39; }
}

my int $i;
B.new.m($i);
# OUTPUT: «B::Int␤»</pre>
<p><a name="Documentable/integration-test/index-entry-only_method"></a></p>
<h4 id="Only_method"><a class="u" href="#___top" title="go to top of document">Only method</a></h4>
<p>To explicitly state that a method is not a multi method use the <code>only</code> method declarator.</p>
<pre class="pod-block-code">class C {
    only method m {};
    multi method m {};
};
# OUTPUT: «X::Comp::AdHoc: Cannot have a multi candidate for &#39;m&#39; when an only method is also in the package &#39;C&#39;␤»
</pre>
<h4 id="submethod_BUILD"><a class="u" href="#___top" title="go to top of document">submethod BUILD</a></h4>
<p>The <a href="/Documentable/integration-test/type/Submethod">submethod</a> <code>BUILD</code> is (indirectly) called by <a href="/Documentable/integration-test/type/Mu#method_bless">.bless</a>. It is meant to set private and public attributes of a class and receives all names attributes passed into <code>.bless</code>. The default constructor <a href="/Documentable/integration-test/type/Mu#method_new">.new</a> defined in <code>Mu</code> is the method that invokes it. Given that public accessor methods are not available in <code>BUILD</code>, you must use private attribute notation instead.</p>
<pre class="pod-block-code">class C {
    has $.attr;
    submethod BUILD (:$attr = 42) {
        $!attr = $attr
    };
    multi method new($positional) {
        self.bless(:attr($positional), |%_)
   }
};

C.new.say; C.new(&#39;answer&#39;).say;
# OUTPUT: «C.new(attr =&gt; 42)␤
#          C.new(attr =&gt; &quot;answer&quot;)␤»</pre>
<h4 id="Fallback_method"><a class="u" href="#___top" title="go to top of document">Fallback method <a name="Documentable/integration-test/index-entry-FALLBACK_(method)"></a></a></h4>
<p>A method with the special name <code>FALLBACK</code> will be called when other means to resolve the name produce no result. The first argument holds the name and all following arguments are forwarded from the original call. Multi methods and <a href="/Documentable/integration-test/type/Signature#Sub-signatures">sub-signatures</a> are supported.</p>
<pre class="pod-block-code">class Magic {
    method FALLBACK ($name, |c(Int, Str)) {
    put &quot;$name called with parameters {c.raku}&quot;  }
};
Magic.new.simsalabim(42, &quot;answer&quot;);

# OUTPUT: «simsalabim called with parameters ⌈\(42, &quot;answer&quot;)⌋␤»</pre>
<p><a name="Documentable/integration-test/index-entry-WHAT_(reserved_method)"></a><a name="Documentable/integration-test/index-entry-WHO_(reserved_method)"></a> <a name="Documentable/integration-test/index-entry-HOW_(reserved_method)"></a><a name="Documentable/integration-test/index-entry-VAR_(reserved_method)"></a></p>
<h4 id="Reserved_method_names"><a class="u" href="#___top" title="go to top of document">Reserved method names</a></h4>
<p>Some built-in introspection methods are actually special syntax provided by the compiler, namely <code>WHAT</code>, <code>WHO</code>, <code>HOW</code> and <code>VAR</code>. Declaring methods with those names will silently fail. A dynamic call will work, what allows to call methods from foreign objects.</p>
<pre class="pod-block-code">class A {
    method WHAT { &quot;ain&#39;t gonna happen&quot; }
};

say A.new.WHAT;    # OUTPUT: «(A)␤»
say A.new.&quot;WHAT&quot;() # OUTPUT: «ain&#39;t gonna happen␤»
</pre>
<h4 id="Methods_in_package_scope"><a class="u" href="#___top" title="go to top of document">Methods in package scope</a></h4>
<p>Any <code>our</code> scoped method will be visible in the package scope of a class.</p>
<pre class="pod-block-code">class C {
    our method packaged {};
    method loose {}
};
say C::.keys
# OUTPUT: «(&amp;packaged)␤»</pre>
<h4 id="Setting_attributes_with_namesake_variables_and_methods"><a class="u" href="#___top" title="go to top of document">Setting attributes with namesake variables and methods</a></h4>
<p>Instead of writing <code>attr =&gt; $attr </code> or <code>:attr($attr)</code>, you can save some typing if the variable (or method call) you&#39;re setting the attribute with shares the name with the attribute:</p>
<pre class="pod-block-code">class A { has $.i = 42 };
class B {
    has $.i = &quot;answer&quot;;
    method m() { A.new(:$.i) }
    #                  ^^^^  Instead of i =&gt; $.i or :i($.i)
};
my $a = B.new.m;
say $a.i; # OUTPUT: «answer␤»</pre>
<p>Since <code>$.i</code> method call is named <code>i</code> and the attribute is also named <code>i</code>, Raku lets us shortcut. The same applies to <code>:$var</code>, <code>:$!private-attribute</code>, <code>:&amp;attr-with-code-in-it</code>, and so on.</p>
<h3 id="trait_is_nodal"><a class="u" href="#___top" title="go to top of document">trait <code>is nodal</code></a></h3>
<p>Marks a <a href="/Documentable/integration-test/type/List">List</a> method to indicate to hyperoperator to not descend into inner <a href="/Documentable/integration-test/type/Iterable">Iterables</a> to call this method. This trait generally isn&#39;t something end users would be using, unless they&#39;re subclassing or augmenting core <a href="/Documentable/integration-test/type/List">List</a> type.</p>
<p>In order to demonstrate the difference consider the following examples, the first using a method (<code>elems</code>) that <code>is nodal</code> and the second using a method (<code>Int</code>) which is not nodal.</p>
<pre class="pod-block-code">say ((1.0, &quot;2&quot;, 3e0), [^4], &#39;5&#39;)».elems; # OUTPUT: «(3, 4, 1)␤»
say ((1.0, &quot;2&quot;, 3e0), [^4], &#39;5&#39;)».Int    # OUTPUT: «((1 2 3) [0 1 2 3] 5)␤»</pre>
<h3 id="trait_handles"><a class="u" href="#___top" title="go to top of document">trait <a name="Documentable/integration-test/index-entry-handles_trait-handles"><span class="index-entry"><code>handles</code></span></a></a></h3>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub trait_mod:&lt;handles&gt;(Attribute:D $target, $thunk)</pre>
<p>The <a href="/Documentable/integration-test/type/Sub#Traits">trait</a> <code>handles</code> applied to an attribute of a class will delegate all calls to the provided method name to the method with the same name of the attribute. The object referenced by the attribute must be initialized. A type constraint for the object that the call is delegated to can be provided.</p>
<pre class="pod-block-code">class A      { method m(){ &#39;A::m has been called.&#39; } }
class B is A { method m(){ &#39;B::m has been called.&#39; } }
class C {
    has A $.delegate handles &#39;m&#39;;
    method new($delegate){ self.bless(delegate =&gt; $delegate) }
};
say C.new(B.new).m(); # OUTPUT: «B::m has been called.␤»</pre>
<p>Instead of a method name, a <code>Pair</code> (for renaming), a list of names or <code>Pair</code>s, a <code>Regex</code> or a <code>Whatever</code> can be provided. In the latter case existing methods, both in the class itself and its inheritance chain, will take precedence. If even local <a name="Documentable/integration-test/index-entry-FALLBACK_(trait_handles)-FALLBACK"><span class="index-entry"><code>FALLBACK</code></span></a>s should be searched, use a <a href="/Documentable/integration-test/type/HyperWhatever"><code>HyperWhatever</code></a>.</p>
<pre class="pod-block-code">class A {
    method m1(){ &#39;A::m1 has been called.&#39; }
    method m2(){ &#39;A::m2 has been called.&#39; }
}

class C {
    has $.delegate handles &lt;m1 m2&gt; = A.new()
}
say C.new.m2; # OUTPUT: «A::m2 has been called.␤»

class D {
    has $.delegate handles /m\d/ = A.new()
}
say D.new.m1; # OUTPUT: «A::m1 has been called.␤»

class E {
    has $.delegate handles (em1 =&gt; &#39;m1&#39;) = A.new()
}
say E.new.em1; # OUTPUT: «A::m1 has been called.␤»</pre>
<h3 id="trait_is"><a class="u" href="#___top" title="go to top of document"><a name="Documentable/integration-test/index-entry-classes_is-trait_is"><span class="index-entry">trait <code>is</code></span></a></a></h3>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub trait_mod:&lt;is&gt;(Mu:U $child, Mu:U $parent)</pre>
<p>The <a href="/Documentable/integration-test/type/Sub#Traits">trait</a> <code>is</code> accepts a type object to be added as a parent class of a class in its definition. To allow multiple inheritance the trait can be applied more than once. Adding parents to a class will import their methods into the target class. If the same method name occurs in multiple parents, the first added parent will win.</p>
<p>If no <code>is</code> trait is provided the default of <a href="/Documentable/integration-test/type/Any"><code>Any</code></a> will be used as a parent class. This forces all Raku objects to have the same set of basic methods to provide an interface for introspection and coercion to basic types.</p>
<pre class="pod-block-code">class A {
    multi method from-a(){ &#39;A::from-a&#39; }
}
say A.new.^parents(:all).raku;
# OUTPUT: «(Any, Mu)␤»

class B {
    method from-b(){ &#39;B::from-b &#39; }
    multi method from-a(){ &#39;B::from-A&#39; }
}

class C is A is B {}
say C.new.from-a();
# OUTPUT: «A::from-a␤»</pre>
<h3 id="trait_is_rw"><a class="u" href="#___top" title="go to top of document">trait <a name="Documentable/integration-test/index-entry-is_rw_(class)-is_rw"><span class="index-entry"><code>is rw</code></span></a></a></h3>
<p>Defined as:</p>
<pre class="pod-block-code">sub trait_mod:&lt;is&gt;(Mu:U $type, :$rw!)</pre>
<p>The <a href="/Documentable/integration-test/type/Sub#Traits">trait</a> <code>is rw</code> on a class will create writable accessor methods on all public attributes of that class.</p>
<pre class="pod-block-code">class C is rw {
    has $.a;
};
my $c = C.new.a = 42;
say $c; # OUTPUT: «42␤»</pre>
<h3 id="trait_is_required"><a class="u" href="#___top" title="go to top of document">trait <code>is required</code></a></h3>
<p>Defined as:</p>
<pre class="pod-block-code">multi sub trait_mod:&lt;is&gt;(Attribute $attr, :$required!)
multi sub trait_mod:&lt;is&gt;(Parameter:D $param, :$required!)</pre>
<p>Marks a class or roles attribute as required. If the attribute is not initialized at object construction time throws <a href="/Documentable/integration-test/type/X::Attribute::Required">X::Attribute::Required</a>.</p>
<pre class="pod-block-code">class Correct {
    has $.attr is required;
    submethod BUILD (:$attr) { $!attr = $attr }
}
say Correct.new(attr =&gt; 42);
# OUTPUT: «Correct.new(attr =&gt; 42)␤»

class C {
    has $.attr is required;
}
C.new;
CATCH { default { say .^name =&gt; .Str } }
# OUTPUT: «X::Attribute::Required =&gt; The attribute &#39;$!attr&#39; is required, but you did not provide a value for it.␤»</pre>
<p>You can provide a reason why it&#39;s required as an argument to <code>is required</code></p>
<pre class="pod-block-code">class Correct {
    has $.attr is required(&quot;it&#39;s so cool&quot;)
};
say Correct.new();
# OUTPUT: «The attribute &#39;$!attr&#39; is required because it&#39;s so cool,␤but you did not provide a value for it.␤»
</pre>
<h3 id="trait_hides"><a class="u" href="#___top" title="go to top of document">trait <code>hides</code></a></h3>
<p>The trait <code>hides</code> provides inheritance without being subject to <a href="/Documentable/integration-test/language/functions#Re-dispatching">re-dispatching</a>.</p>
<pre class="pod-block-code">class A {
    method m { say &#39;i am hidden&#39; }
}
class B hides A {
    method m { nextsame }
    method n { self.A::m }
};

B.new.m;
B.new.n;
# OUTPUT: «i am hidden␤»</pre>
<p>The trait <code>is hidden</code> allows a class to hide itself from <a href="/Documentable/integration-test/language/functions#Re-dispatching">re-dispatching</a>.</p>
<pre class="pod-block-code">class A is hidden {
    method m { say &#39;i am hidden&#39; }
}
class B is A {
    method m { nextsame }
    method n { self.A::m }
}

B.new.m;
B.new.n;
# OUTPUT: «i am hidden␤»</pre>
<h3 id="trait_trusts"><a class="u" href="#___top" title="go to top of document">trait <code>trusts</code></a></h3>
<p>To allow one class to access the private methods of another class use the trait <code>trusts</code>. A forward declaration of the trusted class may be required.</p>
<pre class="pod-block-code">class B {...};
class A {
    trusts B;
    has $!foo;
    method !foo { return-rw $!foo }
    method perl { &quot;A.new(foo =&gt; $!foo)&quot; }
};
class B {
    has A $.a .= new;
    method change { $!a!A::foo = 42; self }
};
say B.new.change;
# OUTPUT: «B.new(a =&gt; A.new(foo =&gt; 42))␤»</pre>
<h3 id="Augmenting_a_class"><a class="u" href="#___top" title="go to top of document">Augmenting a class</a></h3>
<p>To add methods and attributes to a class at compile time use <code>augment</code> in front of a class definition fragment. The compiler will demand the pragmas <code>use MONKEY-TYPING</code> or <code>use MONKEY</code> early in the same scope. Please note that there may be performance implications, hence the pragmas.</p>
<pre class="pod-block-code">use MONKEY; augment class Str {
    method mark(Any :$set){
        state $mark //= $set; $mark
    }
};
my $s = &quot;42&quot;;
$s.mark(set =&gt; &quot;answer&quot;);
say $s.mark
# OUTPUT: «answer␤»</pre>
<p>There are few limitations of what can be done inside the class fragment. One of them is the redeclaration of a method or sub into a multi. Using added attributes is not yet implemented. Please note that adding a multi candidate that differs only in its named parameters will add that candidate behind the already defined one and as such it won&#39;t be picked by the dispatcher.</p>
<h2 id="role"><a class="u" href="#___top" title="go to top of document"><code>role</code></a></h2>
<p><a name="Documentable/integration-test/index-entry-declarator_role_(typesystem)"></a> Roles are class fragments, which allow the definition of interfaces that are shared by classes. The <code>role</code> declarator also introduces a type object that can be used for type checks. Roles can be mixed into classes and objects at runtime and compile time. The <code>role</code> declarator returns the created type object thus allowing the definition of anonymous roles and in-place mixins.</p>
<pre class="pod-block-code">role Serialize {
    method to-string { self.Str }
    method to-number { self.Num }
}

class A does Serialize {}
class B does Serialize {}

my Serialize @list;
@list.push: A.new;
@list.push: B.new;

say @list».to-string;
# OUTPUT: «[A&lt;57192848&gt; B&lt;57192880&gt;]␤»</pre>
<p>Use <code>...</code> as the only element of a method body to declare a method to be abstract. Any class getting such a method mixed in has to overload it. If the method is not overloaded before the end of the compilation unit <code>X::Comp::AdHoc</code> will be thrown.</p>
<pre class="pod-block-code">EVAL &#39;role R { method overload-this(){...} }; class A does R {}; &#39;;
CATCH { default { say .^name, &#39; &#39;, .Str } }
# OUTPUT: «X::Comp::AdHoc Method &#39;overload-this&#39; must be implemented by A because it is required by roles: R.␤»</pre>
<h3 id="Auto-punning"><a class="u" href="#___top" title="go to top of document">Auto-punning</a></h3>
<p>A role can be used instead of a class to create objects. Since roles can&#39;t exist at runtime, a class of the same name is created that will type check successful against the role.</p>
<pre class="pod-block-code">role R { method m { say &#39;oi‽&#39; } };
R.new.^mro.say;
# OUTPUT: «((R) (Any) (Mu))␤»
say R.new.^mro[0].HOW.^name;
# OUTPUT: «Perl6::Metamodel::ClassHOW␤»
say R.new ~~ R;
# OUTPUT: «True␤»</pre>
<h3 id="trait_does"><a class="u" href="#___top" title="go to top of document">trait <code>does</code></a></h3>
<p>The trait <code>does</code> can be applied to roles and classes providing compile time mixins. To refer to a role that is not defined yet, use a forward declaration. The type name of the class with mixed in roles does not reflect the mixin, a type check does. If methods are provided in more than one mixed in role, the method that is defined first takes precedence. A list of roles separated by comma can be provided. In this case conflicts will be reported at compile time.</p>
<pre class="pod-block-code">role R2 {...};
role R1 does R2 {};
role R2 {};
class C does R1 {};

say [C ~~ R1, C ~~ R2];
# OUTPUT: «[True True]␤»</pre>
<p>For runtime mixins see <a href="/Documentable/integration-test/language/operators#infix_but">but</a> and <a href="/Documentable/integration-test/language/operators#infix_does">does</a>.</p>
<h3 id="Parameterized"><a class="u" href="#___top" title="go to top of document">Parameterized</a></h3>
<p>Roles can be provided with parameters in-between <code>[]</code> behind a roles name. <a name="Documentable/integration-test/index-entry-Type_Capture_(role)"></a><a href="/Documentable/integration-test/type/Signature#Type_captures">Type captures</a> are supported.</p>
<pre class="pod-block-code">role R[$d] { has $.a = $d };
class C does R[&quot;default&quot;] { };

my $c = C.new;
say $c;
# OUTPUT: «C.new(a =&gt; &quot;default&quot;)␤»</pre>
<p>Parameters can have type constraints, <code>where</code> clauses are not supported for types but can be implemented via <a href="#subset"><code>subset</code>s</a>.</p>
<pre class="pod-block-code">class A {};
class B {};
subset A-or-B where * ~~ A|B;
role R[A-or-B ::T] {};
R[A.new].new;</pre>
<p>Default parameters can be provided.</p>
<pre class="pod-block-code">role R[$p = fail(&quot;Please provide a parameter to role R&quot;)] {};
my $i = 1 does R;
CATCH { default { say .^name, &#39;: &#39;, .Str} }
# OUTPUT: «X::AdHoc: Could not instantiate role &#39;R&#39;:␤Please provide a parameter to role R␤»</pre>
<h3 id="As_type_constraints"><a class="u" href="#___top" title="go to top of document">As type constraints</a></h3>
<p>Roles can be used as type constraints wherever a type is expected. If a role is mixed in with <code>does</code> or <code>but</code>, its type-object is added to the type-object list of the object in question. If a role is used instead of a class (using auto-punning), the auto-generated class&#39; type-object, of the same name as the role, is added to the inheritance chain.</p>
<pre class="pod-block-code">role Unitish[$unit = fail(&#39;Please provide a SI unit quantifier as a parameter to the role Unitish&#39;)] {
    has $.SI-unit-symbol = $unit;
    method gist {
        given self {
            # ...
            when * &lt; 1 { return self * 1000 ~ &#39;m&#39; ~ $.SI-unit-symbol }
            when * &lt; 1000 { return self ~ $.SI-unit-symbol }
            when * &lt; 1_000_000 { return self / 1_000 ~ &#39;k&#39; ~ $.SI-unit-symbol }
            # ...
        }
    }
}

role SI-second   does Unitish[&lt;s&gt;] {}
role SI-meter    does Unitish[&lt;m&gt;] {}
role SI-kilogram does Unitish[&lt;g&gt;] {}

sub postfix:&lt;s&gt;(Numeric $num) { ($num) does SI-second }
sub postfix:&lt;m&gt;(Numeric $num) { ($num) does SI-meter }
sub postfix:&lt;g&gt;(Numeric $num) { ($num) does SI-kilogram }
sub postfix:&lt;kg&gt;(Numeric $num){ ($num * 1000) does SI-kilogram }

constant g = 9.806_65;

role SI-Newton does Unitish[&lt;N&gt;] {}

multi sub N(SI-kilogram $kg, SI-meter $m, SI-second $s --&gt; SI-Newton ){ ($kg * ($m / $s²)) does SI-Newton }
multi sub N(SI-kilogram $kg --&gt; SI-Newton)                            { ($kg * g) does SI-Newton }

say [75kg, N(75kg)];
# OUTPUT: «[75kg 735.49875kN]␤»
say [(75kg).^name, N(75kg).^name];
# OUTPUT: «[Int+{SI-kilogram} Rat+{SI-Newton}]␤»
</pre>
<p><a name="Documentable/integration-test/index-entry-Enumeration-_Enums-_enum"></a></p>
<h2 id="enum"><a class="u" href="#___top" title="go to top of document"><code>enum</code></a></h2>
<p>Enumerations provide constant key-value-pairs with an associated type. Any key is of that type and injected as a symbol into the current scope. If the symbol is used, it is treated as a constant expression and the symbol is replaced with the value of the enum-pair. Any Enumeration inherits methods from the role <a href="/Documentable/integration-test/type/Enumeration"><code>Enumeration</code></a>. Complex expressions for generating key-value pairs are not supported. In general, an <code>enum</code> is a <a href="/Documentable/integration-test/type/Map">Map</a> whose elements have the <code>Enumeration</code> role mixed in; this role includes, for each element, an index which creates an order on the map.</p>
<p>Stringification of the symbol, which is done automatically in string context and is exactly equal to its name, which is also the key of the enum-pair.</p>
<pre class="pod-block-code">enum Names ( name1 =&gt; 1, name2 =&gt; 2 );
say name1, &#39; &#39;, name2; # OUTPUT: «name1 name2␤»
say name1.value, &#39; &#39;, name2.value; # OUTPUT: «1 2␤»</pre>
<p>Comparing symbols will use type information and the value of the enum-pair. As value types <code>Num</code> and <code>Str</code> are supported.</p>
<pre class="pod-block-code">enum Names ( name1 =&gt; 1, name2 =&gt; 2 );
sub same(Names $a, Names $b){
   $a eqv $b
}

say same(name1, name1); # OUTPUT: «True␤»
say same(name1, name2); # OUTPUT: «False␤»
my $a = name1;
say $a ~~ Names; # OUTPUT: «True␤»
say $a.^name;    # OUTPUT: «Names␤»</pre>
<p>All keys have to be of the same type.</p>
<pre class="pod-block-code">enum Mass ( mg =&gt; 1/1000, g =&gt; 1/1, kg =&gt; 1000/1 );

say Mass.enums;
# OUTPUT: «Map.new((g =&gt; 1, kg =&gt; 1000, mg =&gt; 0.001))␤»</pre>
<p>And you can use any kind of symbol:</p>
<pre class="pod-block-code">enum Suit &lt;♣ ♦ ♥ ♠&gt;;</pre>
<p>As long as you refer to that symbol using the full syntax:</p>
<pre class="pod-block-code">say Suit::&lt;♣&gt;; # OUTPUT: «♣␤»
my $heart = &#39;♥&#39;;
say Suit::«$heart»; # OUTPUT: «♥␤»
</pre>
<p>Attempting to access unicode enum keys without said syntax will result in an error:</p>
<pre class="pod-block-code">say ♣ ; # OUTPUT: «(exit code 1) ===SORRY!===␤Argument to &quot;say&quot; seems to be    malformed…
</pre>
<p>If no value is given <code>Int</code> will be assumed as the values type and incremented by one per key starting at zero. As enum key types <code>Int</code>, <code>Num</code>, <code>Rat</code> and <code>Str</code> are supported.</p>
<pre class="pod-block-code">enum Numbers &lt;one two three four&gt;;

say Numbers.enums;
# OUTPUT: «Map.new((four =&gt; 3, one =&gt; 0, three =&gt; 2, two =&gt; 1))␤»</pre>
<p>A different starting value can be provided.</p>
<pre class="pod-block-code">enum Numbers «:one(1) two three four»;

say Numbers.enums;
# OUTPUT: «Map.new((four =&gt; 4, one =&gt; 1, three =&gt; 3, two =&gt; 2))␤»</pre>
<p>You can also do this with the <strong>()</strong> form of the initializer, but will need to quote keys that do not have a value:</p>
<pre class="pod-block-code">enum Numbers (
  one =&gt; 1,
  &#39;two&#39;,
  &#39;three&#39;,
  &#39;four&#39;
);</pre>
<p>Enums can also be anonymous, with the only difference with named <code>enum</code>s being that you cannot use it in <code>Signature</code>s or to declare variables.</p>
<pre class="pod-block-code">my $e = enum &lt;one two three&gt;;
say two;       # OUTPUT: «two␤»
say one.^name; # OUTPUT: «␤»
say $e.^name;  # OUTPUT: «Map␤»</pre>
<p>There are various methods to get access to the keys and values of the symbols that have been defined. All of them turn the values into <code>Str</code>, which may not be desirable. By treating the enum as a package, we can get a list of types for the keys.</p>
<pre class="pod-block-code">enum E &lt;one two&gt;;
my @keys = E::.values;
say @keys.map: *.raku;
# OUTPUT: «(E::one E::two)␤»</pre>
<p>With the use of <strong>()</strong> parentheses, an enum can be defined using any arbitrary dynamically defined list. The list should consist of Pair objects:</p>
<p>For example, in file <code>config</code> we have:</p>
<pre class="pod-block-code">a 1
b 2
</pre>
<p>We can create an enum using it with this code:</p>
<pre class="pod-block-code">enum ConfigValues (&#39;config&#39;.IO.lines.map({ my ($key, $value) = $_.words; $key =&gt; $value }));
say ConfigValues.enums;          # OUTPUT: «Map.new((a =&gt; 1, b =&gt; 2))␤»
</pre>
<p>Firstly, we read lines from <code>config</code> file, split every line using <code>words</code> method and return resulting pair for every line, thus creating a List of Pairs.</p>
<h3 id="Typing_Enums"><a class="u" href="#___top" title="go to top of document">Typing Enums</a></h3>
<p>When declaring enums with an explicit scope, a type may be provided, which will be used to typecheck the enum&#39;s values:</p>
<pre class="pod-block-code">my Str enum Foo (foo =&gt; &#39;foo&#39;);
</pre>
<p>All enum pairs are typed as <a href="/Documentable/integration-test/type/Enumeration">Enumeration</a>. In addition, when the enum values are typed as <code>Numeric</code>, <code>Stringy</code>, or a combination of these two types, enum pairs also do the <code>NumericEnumeration</code>, <code>StringyEnumeration</code>, and <code>NumericStringyEnumeration</code> roles respectively. These simply determine how enum pairs get stringified with the <code>Str</code> method.</p>
<p>Given that these types are roles, naturally you can provide your own roles when declaring an enum, which allows you to give them custom behavior and state. For example, to make it simpler to check if a number matches a flag in a bitmask enum, you could write a <code>BitmaskEnumeration</code> role with an <code>ACCEPTS</code> method to handle this via smartmatching:</p>
<pre class="pod-block-code">role BitmaskEnumeration {
    multi method ACCEPTS(::?CLASS:D: Int:D $value --&gt; Bool:D) {
        so $value +&amp; self.value
    }
}

enum Flags does BitmaskEnumeration (
    FLAG_FOO =&gt; 0b001,
    FLAG_BAR =&gt; 0b010,
    FLAG_BAZ =&gt; 0b100,
);

say 0b111 ~~ FLAG_FOO &amp; FLAG_BAR &amp; FLAG_BAZ; # OUTPUT: «True␤»
</pre>
<h3 id="Metaclass"><a class="u" href="#___top" title="go to top of document">Metaclass</a></h3>
<p>To test if a given type object is an <code>enum</code>, test the metaobject method <code>.HOW</code> against <a href="/Documentable/integration-test/type/Metamodel::EnumHOW">Metamodel::EnumHOW</a> or simply test against the <code>Enumeration</code> role.</p>
<pre class="pod-block-code">enum E(&lt;a b c&gt;);
say E.HOW ~~ Metamodel::EnumHOW; # OUTPUT: «True␤»
say E ~~ Enumeration;            # OUTPUT: «True␤»</pre>
<h3 id="Methods"><a class="u" href="#___top" title="go to top of document">Methods</a></h3>
<h4 id="method_enums"><a class="u" href="#___top" title="go to top of document">method enums</a></h4>
<p>Defined as:</p>
<pre class="pod-block-code">method enums()</pre>
<p>Returns the list of enum-pairs.</p>
<pre class="pod-block-code">enum Mass ( mg =&gt; 1/1000, g =&gt; 1/1, kg =&gt; 1000/1 );
say Mass.enums; # OUTPUT: «{g =&gt; 1, kg =&gt; 1000, mg =&gt; 0.001}␤»</pre>
<h3 id="Coercion"><a class="u" href="#___top" title="go to top of document">Coercion</a></h3>
<p>If you want to coerce the value of an enum element to its proper enum object, use the coercer with the name of the enum:</p>
<pre class="pod-block-code">my enum A (sun =&gt; 42, mon =&gt; 72);
A(72).pair.say;   # OUTPUT: «mon =&gt; 72␤»
A(1000).say; # OUTPUT: «(A)␤»</pre>
<p>The last example shows what happens if there is no enum-pair that includes that as a value.</p>
<h2 id="module"><a class="u" href="#___top" title="go to top of document"><code>module</code></a></h2>
<p>Modules are usually one or more source files that expose Raku constructs, such as classes, roles, grammars, subroutines and variables. Modules are usually used for distributing Raku code as libraries which can be used in another Raku program.</p>
<p>For a full explanation see <a href="/Documentable/integration-test/language/modules">Modules</a>.</p>
<h2 id="package"><a class="u" href="#___top" title="go to top of document"><code>package</code></a></h2>
<p>Packages are nested namespaces of named program elements. Modules, classes and grammars are all types of package.</p>
<p>For a full explanation see <a href="/Documentable/integration-test/language/packages">Packages</a>.</p>
<h2 id="grammar"><a class="u" href="#___top" title="go to top of document"><code>grammar</code></a></h2>
<p>Grammars are a specific type of class intended for parsing text. Grammars are composed of rules, tokens and regexes which are actually methods, since grammars are classes.</p>
<p>For a full explanation see <a href="/Documentable/integration-test/language/grammars">Grammars</a>.</p>
<h2 id="subset"><a class="u" href="#___top" title="go to top of document"><code>subset</code></a></h2>
<p>A <a name="Documentable/integration-test/index-entry-subset-subset"><span class="index-entry"><code>subset</code></span></a> declares a new type that will re-dispatch to its base type. If a <a href="/Documentable/integration-test/type/Signature#where"><code>where</code></a> clause is supplied any assignment will be checked against the given code object.</p>
<pre class="pod-block-code">subset Positive of Int where * &gt; -1;
my Positive $i = 1;
$i = -42;
CATCH { default { put .^name,&#39;: &#39;, .Str } }
# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $i; expected Positive but got Int (-42)␤»</pre>
<p>Subsets can be used in signatures, e.g. by typing the output:</p>
<pre class="pod-block-code">subset Foo of List where (Int,Str);
sub a($a, $b, --&gt; Foo) { $a, $b }
# Only a List with the first element being an Int and the second a Str will pass the type check.
a(1, &quot;foo&quot;);  # passes
a(&quot;foo&quot;, 1);  # fails</pre>
<p>Subsets can be anonymous, allowing inline placements where a subset is required but a name is neither needed nor desirable.</p>
<pre class="pod-block-code">my enum E1 &lt;A B&gt;;
my enum E2 &lt;C D&gt;;
sub g(@a where { .all ~~ subset :: where E1|E2 } ) {
    say @a
}
g([A, C]);
# OUTPUT: «[A C]␤»</pre>
<p>Subsets can be used to check types dynamically, which can be useful in conjunction with <a href="/Documentable/integration-test/language/modules#require">require</a>. <a name="Documentable/integration-test/index-entry-dynamic_subset"></a></p>
<pre class="pod-block-code">require ::(&#39;YourModule&#39;);
subset C where ::(&#39;YourModule::C&#39;);
</pre>
<p><a name="Documentable/integration-test/index-entry-:ver<>"></a><a name="Documentable/integration-test/index-entry-:auth<>"></a><a name="Documentable/integration-test/index-entry-:api<>"></a></p>
<h1 id="Versioning,_authorship,_and_API_version."><a class="u" href="#___top" title="go to top of document">Versioning, authorship, and API version.</a></h1>
<p>When you declare a type you can pass it a version, author, and/or API number, all of which you can subsequently introspect. The versioning, authorship, and/or API number of a type can be applied via the adverbs <code>:ver&lt;&gt;</code>, <code>:auth&lt;&gt;</code>, and <code>:api&lt;&gt;</code> respectively. All of them take a string as argument; for <code>:ver</code> the string is converted to a <a href="/Documentable/integration-test/type/Version"><code>Version</code></a> object, and for <code>:api</code> the string is converted into an <a href="/Documentable/integration-test/language/glossary#index-entry-Allomorph">allomorph</a> <a href="/Documentable/integration-test/type/IntStr"><code>IntStr</code></a> object. <code>:auth</code> generally takes the form <code>hosting:ID</code>, as in <code>github:github-user</code> or <code>gitlab:gitlab-user</code>.</p>
<p>To query the version, author, and API version of a type use <a href="/Documentable/integration-test/type/Metamodel::Versioning#method_ver"><code>.^ver</code></a>, <a href="/Documentable/integration-test/type/Metamodel::Versioning#method_auth"><code>.^auth</code></a>, and <a href="/Documentable/integration-test/type/Metamodel::Versioning#method_api"><code>.^api</code></a> respectively, as illustrated down below by querying a <code>class</code>.</p>
<pre class="pod-block-code">class C:ver&lt;4.2.3&gt;:auth&lt;github:jane&gt;:api&lt;1&gt; {}
say C.^ver;       # OUTPUT: «v4.2.3␤»
say C.^ver.parts; # OUTPUT: «(4 2 3)␤»
say C.^auth;      # OUTPUT: «github:jane␤»
say C.^api;       # OUTPUT: «1␤»</pre>
<p>In a similar fashion, <code>role</code>s, <code>grammar</code>s, and <code>module</code>s can be queried about the aforementioned information.</p>

        </div>
    </div>

    

    <footer class="pretty-box yellow">
        <p>
            Generated from <a href="https://github.com/Raku/doc/blob/master/doc/Language/typesystem.pod6">https://github.com/Raku/doc/blob/master/doc/Language/typesystem.pod6</a>.
        </p>
        <p>
            This is a work in progress to document Raku (formerly known as Perl 6), and
            known to be incomplete.
        </p>
        <p>
            <a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md#reporting-bugs">
                Please report any issues
            </a>
            Your contribution is appreciated.
        </p>
        <p>
            This documentation is provided under the terms of the
            <a href="https://raw.githubusercontent.com/raku/doc/master/LICENSE">
                Artistic License 2.0
            </a>. The Camelia image is
            <a href="https://raw.githubusercontent.com/raku/mu/master/misc/camelia.txt">
                copyright © 2009 by Larry Wall.
            </a>
            <!-- CREDITS -->
            <!--External Link Image by Zapyon, CCA-SA 4.0. Derived from Wikimedia Foundation https://commons.wikimedia.org/wiki/File:External-link-04-bold-12x12.svg -->
        </p>
    </footer>

    <script type="text/javascript" src="/Documentable/integration-test/js/app.js?v=1"></script>
    <script type="text/javascript" src="/Documentable/integration-test/js/search.js?v=3"></script>
</body>
</html>

