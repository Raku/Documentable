<!doctype html>
<html lang="en">
<head>
    <title>class Mix</title>
    <meta charset="UTF-8"/>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel="icon" href="/Documentable/integration-test/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="/Documentable/integration-test/css/app.css" media="screen" title="default" />
    <noscript> <style> #search { visibility: hidden; } </style> </noscript>
</head>

<body class="pod">

    <div id="___top"></div>

    <div id="header" class="pretty-box green">

        <a href="/Documentable/integration-test/">
            <img src="/Documentable/integration-test/images/Camelia.svg"alt="»ö«"id="logo"width="62"height="48"/> &nbsp;Raku Documentation
        </a>

        <div id="search" class="ui-widget">
            <div class="green">
                <input placeholder="Loading..." id="query" accesskey="f" title="Enter term to search for (hit Esc to focus)"/>
            </div>
            <p id="not-found-message">
                Not in Index (<a href="" id="try-web-search">try site search</a>)
            </p>
        </div>
        
        <div class="menu">
            
            <div class="menu-items dark-green">
                <a class='menu-item darker-green' href='https://raku.org'><strong>Raku homepage</strong></a>
                    <a class="menu-item " href="/Documentable/integration-test/language.html"> Language </a>
                    <a class="menu-item selected darker-green" href="/Documentable/integration-test/type.html"> Types </a>
                    <a class="menu-item " href="/Documentable/integration-test/routine.html"> Routines </a>
                    <a class="menu-item " href="/Documentable/integration-test/programs.html"> Programs </a>
                    <a class="menu-item " href="https://webchat.freenode.net/?channels=#raku"> Chat with us </a>
            </div>
            
            <div class="menu-items darker-green"><div class="menu-items darker-green"><div class="menu-items darker-green"><div class="menu-items darker-green"><div class="menu-items darker-green">
                    <a class="menu-item" href="/Documentable/integration-test/type.html"> All </a>
                    <a class="menu-item" href="/Documentable/integration-test/type-basic.html"> Basic </a>
                    <a class="menu-item" href="/Documentable/integration-test/type-composite.html"> Composite </a>
                    <a class="menu-item" href="/Documentable/integration-test/type-domain-specific.html"> Domain-specific </a>
                    <a class="menu-item" href="/Documentable/integration-test/type-exception.html"> Exceptions </a>
            </div></div></div></div></div>
        
        </div>
    </div>

    <div id="content" class="pretty-box yellow content_fragment">

        <div align="right" style="display:;">
            <button title="Edit this page"  class="pencil" onclick="location='https://github.com/Raku/doc/edit/master/doc/Type/Mix.pod6'">
                <svg width="14px" height="16px" viewBox="0 0 14 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <defs></defs>
                    <g id="Octicons" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="pencil" fill="#000000">
                            <path d="M0,12 L0,15 L3,15 L11,7 L8,4 L0,12 L0,12 Z M3,14 L1,14 L1,12 L2,12 L2,13 L3,13 L3,14 L3,14 Z M13.3,4.7 L12,6 L9,3 L10.3,1.7 C10.69,1.31 11.32,1.31 11.71,1.7 L13.3,3.29 C13.69,3.68 13.69,4.31 13.3,4.7 L13.3,4.7 Z" id="Shape"></path>
                        </g>
                    </g>
                </svg>
            </button>
        </div>

        <h1 class="title">class Mix</h1>
        <p class="subtitle">Immutable collection of distinct objects with Real weights</p>

        <nav class="indexgroup">
<table id="TOC">
<caption><h2 id="TOC_Title">Table of Contents</h2></caption>
                                       <tr class="toc-level-1"><td class="toc-number">1</td><td class="toc-text"><a href="#Creating_Mix_objects">Creating <code class="pod-code-inline">Mix</code> objects</a></td></tr>
                                         <tr class="toc-level-1"><td class="toc-number">2</td><td class="toc-text"><a href="#Operators">Operators</a></td></tr>
                            <tr class="toc-level-2"><td class="toc-number">2.1</td><td class="toc-text"><a href="#sub_mix">sub mix</a></td></tr>
       <tr class="toc-level-1"><td class="toc-number">3</td><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">3.1</td><td class="toc-text"><a href="#method_Bag">method Bag</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">3.2</td><td class="toc-text"><a href="#method_BagHash">method BagHash</a></td></tr>
              <tr class="toc-level-2"><td class="toc-number">3.3</td><td class="toc-text"><a href="#method_reverse">method reverse</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">3.4</td><td class="toc-text"><a href="#Note_on_order">Note on order</a></td></tr>
      <tr class="toc-level-1"><td class="toc-number">4</td><td class="toc-text"><a href="#See_Also">See Also</a></td></tr>
  <tr class="toc-level-1"><td class="toc-number">5</td><td class="toc-text"><a href="#Type_Graph">Type Graph</a></td></tr>
  <tr class="toc-level-1"><td class="toc-number">6</td><td class="toc-text"><a href="#Routines_supplied_by_role_Mixy">Routines supplied by role Mixy</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">9.1</td><td class="toc-text"><a href="#(Mixy)_method_total">(Mixy) method total</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">9.2</td><td class="toc-text"><a href="#(Mixy)_method_roll">(Mixy) method roll</a></td></tr>
       <tr class="toc-level-1"><td class="toc-number">7</td><td class="toc-text"><a href="#Routines_supplied_by_role_Baggy">Routines supplied by role Baggy</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">9.3</td><td class="toc-text"><a href="#(Baggy)_method_new-from-pairs">(Baggy) method new-from-pairs</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">9.4</td><td class="toc-text"><a href="#(Baggy)_method_grab">(Baggy) method grab</a></td></tr>
                                <tr class="toc-level-2"><td class="toc-number">9.5</td><td class="toc-text"><a href="#(Baggy)_method_grabpairs">(Baggy) method grabpairs</a></td></tr>
                                    <tr class="toc-level-2"><td class="toc-number">9.6</td><td class="toc-text"><a href="#(Baggy)_method_pick">(Baggy) method pick</a></td></tr>
                        <tr class="toc-level-2"><td class="toc-number">9.7</td><td class="toc-text"><a href="#(Baggy)_method_pickpairs">(Baggy) method pickpairs</a></td></tr>
                            <tr class="toc-level-2"><td class="toc-number">9.8</td><td class="toc-text"><a href="#(Baggy)_method_roll">(Baggy) method roll</a></td></tr>
                  <tr class="toc-level-2"><td class="toc-number">9.9</td><td class="toc-text"><a href="#(Baggy)_method_pairs">(Baggy) method pairs</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">9.10</td><td class="toc-text"><a href="#(Baggy)_method_antipairs">(Baggy) method antipairs</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">9.11</td><td class="toc-text"><a href="#(Baggy)_method_invert">(Baggy) method invert</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">9.12</td><td class="toc-text"><a href="#(Baggy)_method_classify-list">(Baggy) method classify-list</a></td></tr>
                                                       <tr class="toc-level-2"><td class="toc-number">9.13</td><td class="toc-text"><a href="#(Baggy)_method_categorize-list">(Baggy) method categorize-list</a></td></tr>
                                                     <tr class="toc-level-2"><td class="toc-number">9.14</td><td class="toc-text"><a href="#(Baggy)_method_keys">(Baggy) method keys</a></td></tr>
           <tr class="toc-level-2"><td class="toc-number">9.15</td><td class="toc-text"><a href="#(Baggy)_method_values">(Baggy) method values</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">9.16</td><td class="toc-text"><a href="#(Baggy)_method_kv">(Baggy) method kv</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">9.17</td><td class="toc-text"><a href="#(Baggy)_method_kxxv">(Baggy) method kxxv</a></td></tr>
               <tr class="toc-level-2"><td class="toc-number">9.18</td><td class="toc-text"><a href="#(Baggy)_method_elems">(Baggy) method elems</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">9.19</td><td class="toc-text"><a href="#(Baggy)_method_total">(Baggy) method total</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">9.20</td><td class="toc-text"><a href="#(Baggy)_method_default">(Baggy) method default</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">9.21</td><td class="toc-text"><a href="#(Baggy)_method_hash">(Baggy) method hash</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">9.22</td><td class="toc-text"><a href="#(Baggy)_method_Bool">(Baggy) method Bool</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">9.23</td><td class="toc-text"><a href="#(Baggy)_method_Set">(Baggy) method Set</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">9.24</td><td class="toc-text"><a href="#(Baggy)_method_SetHash">(Baggy) method SetHash</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">9.25</td><td class="toc-text"><a href="#(Baggy)_method_ACCEPTS">(Baggy) method ACCEPTS</a></td></tr>
                           <tr class="toc-level-1"><td class="toc-number">8</td><td class="toc-text"><a href="#Routines_supplied_by_role_QuantHash">Routines supplied by role QuantHash</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">9.26</td><td class="toc-text"><a href="#(QuantHash)_method_hash">(QuantHash) method hash</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">9.27</td><td class="toc-text"><a href="#(QuantHash)_method_Hash">(QuantHash) method Hash</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">9.28</td><td class="toc-text"><a href="#(QuantHash)_method_of">(QuantHash) method of</a></td></tr>
                 <tr class="toc-level-2"><td class="toc-number">9.29</td><td class="toc-text"><a href="#(QuantHash)_method_keyof">(QuantHash) method keyof</a></td></tr>
       <tr class="toc-level-2"><td class="toc-number">9.30</td><td class="toc-text"><a href="#(QuantHash)_method_Setty">(QuantHash) method Setty</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">9.31</td><td class="toc-text"><a href="#(QuantHash)_method_Baggy">(QuantHash) method Baggy</a></td></tr>
          <tr class="toc-level-2"><td class="toc-number">9.32</td><td class="toc-text"><a href="#(QuantHash)_method_Mixy">(QuantHash) method Mixy</a></td></tr>
        <tr class="toc-level-1"><td class="toc-number">9</td><td class="toc-text"><a href="#Routines_supplied_by_role_Associative">Routines supplied by role Associative</a></td></tr>
    <tr class="toc-level-2"><td class="toc-number">9.33</td><td class="toc-text"><a href="#(Associative)_method_of">(Associative) method of</a></td></tr>
                <tr class="toc-level-2"><td class="toc-number">9.34</td><td class="toc-text"><a href="#(Associative)_method_keyof">(Associative) method keyof</a></td></tr>
         <tr class="toc-level-2"><td class="toc-number">9.35</td><td class="toc-text"><a href="#(Associative)_method_AT-KEY">(Associative) method AT-KEY</a></td></tr>
   <tr class="toc-level-2"><td class="toc-number">9.36</td><td class="toc-text"><a href="#(Associative)_method_EXISTS-KEY">(Associative) method EXISTS-KEY</a></td></tr>
     <tr class="toc-level-2"><td class="toc-number">9.37</td><td class="toc-text"><a href="#(Associative)_method_STORE">(Associative) method STORE</a></td></tr>
            
</table>
</nav>

        <div class="pod-body ">
            <pre class="pod-block-code">class Mix does Mixy { }</pre>
<p>A <code>Mix</code> is an immutable collection of distinct elements in no particular order that each have a real-number weight assigned to them. (For <em>mutable</em> mixes, see <a href="/Documentable/integration-test/type/MixHash">MixHash</a> instead.)</p>
<p><code>Mix</code>es are often used for performing weighted random selections - see <a href="/Documentable/integration-test/routine/roll">.roll</a>.</p>
<p>Objects/values of any type are allowed as mix elements. Within a <code>Mix</code>, items that would compare positively with the <a href="/Documentable/integration-test/routine/===">===</a> operator are considered the same element, with a combined weight.</p>
<pre class="pod-block-code">my $recipe = (butter =&gt; 0.22, sugar =&gt; 0.1,
              flour =&gt; 0.275, sugar =&gt; 0.02).Mix;

say $recipe.elems;      # OUTPUT: «3␤»
say $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»
say $recipe.pairs.sort; # OUTPUT: «&quot;butter&quot; =&gt; 0.22 &quot;flour&quot; =&gt; 0.275 &quot;sugar&quot; =&gt; 0.12␤»
say $recipe.total;      # OUTPUT: «0.615␤»
</pre>
<p><code>Mix</code>es can be treated as object hashes using the <code>{ }</code> postcircumfix operator, which returns the corresponding numeric weight for keys that are elements of the mix, and <code>0</code> for keys that aren&#39;t:</p>
<pre class="pod-block-code">my $recipe = (butter =&gt; 0.22, sugar =&gt; 0.1,
              flour =&gt; 0.275, sugar =&gt; 0.02).Mix;
say $recipe&lt;butter&gt;;     # OUTPUT: «0.22␤»
say $recipe&lt;sugar&gt;;      # OUTPUT: «0.12␤»
say $recipe&lt;chocolate&gt;;  # OUTPUT: «0␤»</pre>
<h1 id="Creating_Mix_objects"><a class="u" href="#___top" title="go to top of document">Creating <code>Mix</code> objects</a></h1>
<p><code>Mix</code>es can be composed using the <a href="#sub_mix">mix</a> subroutine (or <code>Mix.new</code>, for which it is a shorthand). Any positional parameters, regardless of their type, become elements of the mix - with a weight of <code>1</code> for each time the parameter occurred:</p>
<pre class="pod-block-code">my $n = mix &quot;a&quot;, &quot;a&quot;, &quot;b&quot; =&gt; 0, 3.14, π, π; # The Pair is a single element
say $n.keys.map: *.^name; # OUTPUT: «(Rat Pair Num Str)␤»
say $n.pairs;
# OUTPUT: «(3.14 =&gt; 1 (b =&gt; 0) =&gt; 1 3.141592653589793 =&gt; 2 a =&gt; 2)␤»</pre>
<p>Alternatively, the <code>.Mix</code> coercer (or its functional form, <code>Mix()</code>) can be called on an existing object to coerce it to a <code>Mix</code>. Its semantics depend on the type and contents of the object. In general it evaluates the object in list context and creates a mix with the resulting items as elements, although for Hash-like objects or Pair items, only the keys become elements of the mix, and the (cumulative) values become the associated numeric weights:</p>
<pre class="pod-block-code">my $n = (&quot;a&quot;, &quot;a&quot;, &quot;b&quot; =&gt; 0, &quot;c&quot; =&gt; 3.14).Mix;
say $n.keys.map(&amp;WHAT);  # OUTPUT: «((Str) (Str))␤»
say $n.pairs;            # OUTPUT: «(a =&gt; 2 c =&gt; 3.14)␤»</pre>
<p>Elements with a 0 value, as <code>b</code> above, are simply eliminated from the <code>Mix</code>.</p>
<p>Alternatively, since <code>Mix</code>es are <a href="/Documentable/integration-test/type/Associative">Associative</a>, we can use the <code>%</code> sigil to declare them; in that case, we can employ <code>is</code> to declare their type:</p>
<pre class="pod-block-code">my %n is Mix = (&quot;a&quot;, &quot;a&quot;, &quot;b&quot; =&gt; 0, &quot;c&quot; =&gt; 3.14);
say %n.^name; # OUTPUT: «Mix␤»
say %n;       # OUTPUT: «Mix(a(2), c(3.14))␤»</pre>
<p>Since 6.d (2019.03 and later) it is also possible to specify the type of values you would like to allow in a <code>Mix</code>. This can either be done when calling <code>.new</code>:</p>
<pre class="pod-block-code"># only allow strings
my $n = Mix[Str].new: &lt;a b b c c c&gt;;</pre>
<p>or using the masquerading syntax:</p>
<pre class="pod-block-code"># only allow strings
my %m is Mix[Str] = &lt;a b b c c c&gt;;
say %m&lt;b&gt;;  # 2
say %m&lt;d&gt;;  # 0

# only allow whole numbers
my %m is Mix[Int] = &lt;a b b c c c&gt;;
# Type check failed in binding; expected Int but got Str (&quot;a&quot;)</pre>
<h1 id="Operators"><a class="u" href="#___top" title="go to top of document">Operators</a></h1>
<p><code>Mix</code>es can use all kind of set operators returning either <code>Bool</code> or other <code>Mix</code>es:</p>
<pre class="pod-block-code">my $this-mix = (sugar =&gt; ⅓, spice =&gt; ¼, all-things-nice =&gt; ¾);
my $that-mix = ( sugar =&gt; 1, spice =&gt; 2);

say $that-mix (&lt;) $this-mix;     # OUTPUT: «True␤»
say $that-mix (^) $this-mix;     # OUTPUT: «set(all-things-nice)␤»
say $that-mix (+) $this-mix;     # OUTPUT: «Bag(spice(2), sugar)␤»
</pre>
<p>With their equivalent Unicode operators:</p>
<pre class="pod-block-code">say $that-mix ⊂ $this-mix;     # OUTPUT: «True␤»
say $that-mix ⊖ $this-mix;     # OUTPUT: «set(all-things-nice)␤»
say $that-mix ⊎ $this-mix;     # OUTPUT: «Bag(spice(2), sugar)␤»
</pre>
<p>See <a href="/Documentable/integration-test/language/setbagmix#Set/Bag_operators">Set/Bag Operators</a> for a complete list of set and bag operators with detailed explanations.</p>
<h2 id="sub_mix"><a class="u" href="#___top" title="go to top of document">sub mix</a></h2>
<pre class="pod-block-code">sub mix(*@args --&gt; Mix)</pre>
<p>Creates a new <code>Mix</code> from <code>@args</code>.</p>
<h1 id="Methods"><a class="u" href="#___top" title="go to top of document">Methods</a></h1>
<h2 id="method_Bag"><a class="u" href="#___top" title="go to top of document">method Bag</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Bag (--&gt; Bag:D)</pre>
<p>Coerces the <code>Mix</code> to a <a href="/Documentable/integration-test/type/Bag"><code>Bag</code></a>. The weights are convert to <a href="/Documentable/integration-test/type/Int"><code>Int</code></a>, which means the number of keys in the resulting <code>Bag</code> can be fewer than in the original <code>Mix</code>, if any of the weights are negative or truncate to zero.</p>
<h2 id="method_BagHash"><a class="u" href="#___top" title="go to top of document">method BagHash</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method BagHash (--&gt; BagHash:D)</pre>
<p>Coerces the <code>Mix</code> to a <a href="/Documentable/integration-test/type/BagHash"><code>BagHash</code></a>. The weights are convert to <a href="/Documentable/integration-test/type/Int"><code>Int</code></a>, which means the number of keys in the resulting <code>BagHash</code> can be fewer than in the original <code>Mix</code>, if any of the weights are negative or truncate to zero.</p>
<h2 id="method_reverse"><a class="u" href="#___top" title="go to top of document">method reverse</a></h2>
<p><em>Note</em>: This method is inherited from <a href="/Documentable/integration-test/type/Any#routine_reverse">Any</a>, however, <code>Mix</code>es do not have an inherent order and you should not trust it returning a consistent output.</p>
<h2 id="Note_on_order"><a class="u" href="#___top" title="go to top of document">Note on order</a></h2>
<p>Same as the other elements in the <a href="/Documentable/integration-test/language/setbagmix">Bag/Mix suite</a>, order is not guaranteed or consistent and you shouldn&#39;t rely on methods like <code>reverse</code> above returning always the same result.</p>
<h1 id="See_Also"><a class="u" href="#___top" title="go to top of document">See Also</a></h1>
<p><a href="/Documentable/integration-test/language/setbagmix">Sets, Bags, and Mixes</a></p>
<h1 id="Type_Graph"><a class="u" href="#___top" title="go to top of document">Type Graph</a></h1>
<figure>
  <figcaption>Type relations for <code>Mix</code></figcaption>
  <svg width="179pt" height="332pt"
 viewBox="0.00 0.00 179.34 332.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 328)">
<title>perl6&#45;type&#45;graph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-328 175.34,-328 175.34,4 -4,4"/>
<!-- Mix -->
<g id="node1" class="node">
<title>Mix</title>
<g id="a_node1"><a xlink:href="/type/Mix" xlink:title="Mix">
<ellipse fill="none" stroke="#000000" cx="67" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="67" y="-14.3" font-family="FreeSans" font-size="14.00" fill="#000000">Mix</text>
</a>
</g>
</g>
<!-- Any -->
<g id="node3" class="node">
<title>Any</title>
<g id="a_node3"><a xlink:href="/type/Any" xlink:title="Any">
<ellipse fill="none" stroke="#000000" cx="29" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="29" y="-86.3" font-family="FreeSans" font-size="14.00" fill="#000000">Any</text>
</a>
</g>
</g>
<!-- Mix&#45;&gt;Any -->
<g id="edge1" class="edge">
<title>Mix&#45;&gt;Any</title>
<path fill="none" stroke="#000000" d="M58.19,-35.24C53.58,-43.72 47.84,-54.29 42.68,-63.8"/>
<polygon fill="#000000" stroke="#000000" points="39.46,-62.39 37.77,-72.85 45.61,-65.73 39.46,-62.39"/>
</g>
<!-- Mixy -->
<g id="node7" class="node">
<title>Mixy</title>
<g id="a_node7"><a xlink:href="/type/Mixy" xlink:title="Mixy">
<ellipse fill="none" stroke="#6666ff" cx="106" cy="-90" rx="30.59" ry="18"/>
<text text-anchor="middle" x="106" y="-86.3" font-family="FreeSans" font-size="14.00" fill="#6666ff">Mixy</text>
</a>
</g>
</g>
<!-- Mix&#45;&gt;Mixy -->
<g id="edge3" class="edge">
<title>Mix&#45;&gt;Mixy</title>
<path fill="none" stroke="#6666ff" d="M76.05,-35.24C80.7,-43.6 86.49,-53.98 91.73,-63.39"/>
<polygon fill="#6666ff" stroke="#6666ff" points="88.81,-65.33 96.73,-72.37 94.92,-61.93 88.81,-65.33"/>
</g>
<!-- Mu -->
<g id="node2" class="node">
<title>Mu</title>
<g id="a_node2"><a xlink:href="/type/Mu" xlink:title="Mu">
<ellipse fill="none" stroke="#000000" cx="27" cy="-162" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-158.3" font-family="FreeSans" font-size="14.00" fill="#000000">Mu</text>
</a>
</g>
</g>
<!-- Any&#45;&gt;Mu -->
<g id="edge2" class="edge">
<title>Any&#45;&gt;Mu</title>
<path fill="none" stroke="#000000" d="M28.51,-108.3C28.29,-116.02 28.02,-125.29 27.77,-133.89"/>
<polygon fill="#000000" stroke="#000000" points="24.28,-133.8 27.49,-143.9 31.27,-134 24.28,-133.8"/>
</g>
<!-- Associative -->
<g id="node4" class="node">
<title>Associative</title>
<g id="a_node4"><a xlink:href="/type/Associative" xlink:title="Associative">
<ellipse fill="none" stroke="#6666ff" cx="107" cy="-306" rx="64.19" ry="18"/>
<text text-anchor="middle" x="107" y="-302.3" font-family="FreeSans" font-size="14.00" fill="#6666ff">Associative</text>
</a>
</g>
</g>
<!-- QuantHash -->
<g id="node5" class="node">
<title>QuantHash</title>
<g id="a_node5"><a xlink:href="/type/QuantHash" xlink:title="QuantHash">
<ellipse fill="none" stroke="#6666ff" cx="107" cy="-234" rx="54.69" ry="18"/>
<text text-anchor="middle" x="107" y="-230.3" font-family="FreeSans" font-size="14.00" fill="#6666ff">QuantHash</text>
</a>
</g>
</g>
<!-- QuantHash&#45;&gt;Associative -->
<g id="edge4" class="edge">
<title>QuantHash&#45;&gt;Associative</title>
<path fill="none" stroke="#6666ff" d="M107,-252.3C107,-260.02 107,-269.29 107,-277.89"/>
<polygon fill="#6666ff" stroke="#6666ff" points="103.5,-277.9 107,-287.9 110.5,-277.9 103.5,-277.9"/>
</g>
<!-- Baggy -->
<g id="node6" class="node">
<title>Baggy</title>
<g id="a_node6"><a xlink:href="/type/Baggy" xlink:title="Baggy">
<ellipse fill="none" stroke="#6666ff" cx="107" cy="-162" rx="35.19" ry="18"/>
<text text-anchor="middle" x="107" y="-158.3" font-family="FreeSans" font-size="14.00" fill="#6666ff">Baggy</text>
</a>
</g>
</g>
<!-- Baggy&#45;&gt;QuantHash -->
<g id="edge5" class="edge">
<title>Baggy&#45;&gt;QuantHash</title>
<path fill="none" stroke="#6666ff" d="M107,-180.3C107,-188.02 107,-197.29 107,-205.89"/>
<polygon fill="#6666ff" stroke="#6666ff" points="103.5,-205.9 107,-215.9 110.5,-205.9 103.5,-205.9"/>
</g>
<!-- Mixy&#45;&gt;Baggy -->
<g id="edge6" class="edge">
<title>Mixy&#45;&gt;Baggy</title>
<path fill="none" stroke="#6666ff" d="M106.25,-108.3C106.36,-116.02 106.49,-125.29 106.61,-133.89"/>
<polygon fill="#6666ff" stroke="#6666ff" points="103.11,-133.95 106.76,-143.9 110.11,-133.85 103.11,-133.95"/>
</g>
</g>
</svg>

  <p class="fallback">
    <a
      rel="alternate"
      href="/images/type-graph-Mix.svg"
      type="image/svg+xml"
      >Expand above chart</a
    >
  </p>
</figure>
<h1 id="Routines_supplied_by_role_Mixy"><a class="u" href="#___top" title="go to top of document">Routines supplied by role Mixy</a></h1>
<p>Mix does role <a href="/Documentable/integration-test/type/Mixy">Mixy</a>, which provides the following routines:</p>
<h2 id="(Mixy)_method_total"><a href="/Documentable/integration-test/type/Mixy#method_total">(Mixy) method total</a></h2>
<pre class="pod-block-code">method total(--&gt; Real)</pre>
<p>Returns the sum of all the weights</p>
<pre class="pod-block-code">say mix(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;d&#39;).total == 6;  # OUTPUT: «True␤»
say %(a =&gt; 5.6, b =&gt; 2.4).Mix.total == 8;          # OUTPUT: «True␤»</pre>
<h2 id="(Mixy)_method_roll"><a href="/Documentable/integration-test/type/Mixy#method_roll">(Mixy) method roll</a></h2>
<pre class="pod-block-code">method roll($count = 1)</pre>
<p>Similar to a <a href="/Documentable/integration-test/type/Bag">Bag</a>.roll, but with <code>Real</code> weights rather than integral ones.</p>
<h1 id="Routines_supplied_by_role_Baggy"><a class="u" href="#___top" title="go to top of document">Routines supplied by role Baggy</a></h1>
<p>Mix does role <a href="/Documentable/integration-test/type/Baggy">Baggy</a>, which provides the following routines:</p>
<h2 id="(Baggy)_method_new-from-pairs"><a href="/Documentable/integration-test/type/Baggy#method_new-from-pairs">(Baggy) method new-from-pairs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method new-from-pairs(*@pairs --&gt; Baggy:D)</pre>
<p>Constructs a Baggy objects from a list of <a href="/Documentable/integration-test/type/Pair"><code>Pair</code> objects</a> given as positional arguments:</p>
<pre class="pod-block-code">say Mix.new-from-pairs: &#39;butter&#39; =&gt; 0.22, &#39;sugar&#39; =&gt; 0.1, &#39;sugar&#39; =&gt; 0.02;
# OUTPUT: «mix(butter(0.22), sugar(0.12))␤»</pre>
<p><strong>Note:</strong> be sure you aren&#39;t accidentally passing the Pairs as positional arguments; the quotes around the keys in the above example are significant.</p>
<h2 id="(Baggy)_method_grab"><a href="/Documentable/integration-test/type/Baggy#method_grab">(Baggy) method grab</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method grab(Baggy:D: --&gt; Any)
multi method grab(Baggy:D: $count --&gt; Seq:D)</pre>
<p>Like <a href="#method_pick">pick</a>, a <code>grab</code> returns a random selection of elements, weighted by the values corresponding to each key. Unlike <code>pick</code>, it works only on mutable structures, e.g. <a href="/Documentable/integration-test/type/BagHash">BagHash</a>. Use of <code>grab</code> on an immutable structure results in an <code>X::Immutable</code> exception. If <code>*</code> is passed as <code>$count</code>, or <code>$count</code> is greater than or equal to the <a href="#method_total">total</a> of the invocant, then <code>total</code> elements from the invocant are returned in a random sequence; i.e. they are returned shuffled.</p>
<p>Grabbing decrements the grabbed key&#39;s weight by one (deleting the key when it reaches 0). By definition, the <code>total</code> of the invocant also decreases by one, so the probabilities stay consistent through subsequent <code>grab</code> operations.</p>
<pre class="pod-block-code">my $cars = (&#39;Ford&#39; =&gt; 2, &#39;Rover&#39; =&gt; 3).BagHash;
say $cars.grab;                                   # OUTPUT: «Ford␤»
say $cars.grab(2);                                # OUTPUT: «(Rover Rover)␤»
say $cars.grab(*);                                # OUTPUT: «(Rover Ford)␤»

my $breakfast = (&#39;eggs&#39; =&gt; 2, &#39;bacon&#39; =&gt; 3).Bag;
say $breakfast.grab;
CATCH { default { put .^name, &#39;: &#39;, .Str } };
# OUTPUT: «X::Immutable: Cannot call &#39;grab&#39; on an immutable &#39;Bag&#39;␤»</pre>
<h2 id="(Baggy)_method_grabpairs"><a href="/Documentable/integration-test/type/Baggy#method_grabpairs">(Baggy) method grabpairs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method grabpairs(Baggy:D: --&gt; Any)
multi method grabpairs(Baggy:D: $count --&gt; Seq:D)</pre>
<p>Returns a <code>Pair</code> or a <code>Seq</code> of <code>Pair</code>s depending on the version of the method being invoked. Each <code>Pair</code> returned has an element of the invocant as its key and the element&#39;s weight as its value. Unlike <a href="/Documentable/integration-test/routine/pickpairs">pickpairs</a>, it works only on mutable structures, e.g. <a href="/Documentable/integration-test/type/BagHash">BagHash</a>. Use of <code>grabpairs</code> on &#39;an immutable structure results in an <code>X::Immutable</code> exception. If <code>*</code> is passed as <code>$count</code>, or <code>$count</code> is greater than or equal to the number of <a href="#method_elems">elements</a> of the invocant, then all element/weight <code>Pair</code>s from the invocant are returned in a random sequence.</p>
<p>What makes <code>grabpairs</code> different from <a href="#method_pickpairs">pickpairs</a> is that the &#39;grabbed&#39; elements are in fact removed from the invocant.</p>
<pre class="pod-block-code">my $breakfast = (eggs =&gt; 2, bacon =&gt; 3).BagHash;
say $breakfast.grabpairs;                         # OUTPUT: «bacon =&gt; 3␤»
say $breakfast;                                   # OUTPUT: «BagHash.new(eggs(2))␤»
say $breakfast.grabpairs(1);                      # OUTPUT: «(eggs =&gt; 2)␤»
say $breakfast.grabpairs(*);                      # OUTPUT: «()␤»

my $diet = (&#39;eggs&#39; =&gt; 2, &#39;bacon&#39; =&gt; 3).Bag;
say $diet.grabpairs;
CATCH { default { put .^name, &#39;: &#39;, .Str } };
# OUTPUT: «X::Immutable: Cannot call &#39;grabpairs&#39; on an immutable &#39;Bag&#39;␤»</pre>
<h2 id="(Baggy)_method_pick"><a href="/Documentable/integration-test/type/Baggy#method_pick">(Baggy) method pick</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method pick(Baggy:D: --&gt; Any)
multi method pick(Baggy:D: $count --&gt; Seq:D)</pre>
<p>Like an ordinary list <a href="/Documentable/integration-test/type/List#routine_pick">pick</a>, but returns keys of the invocant weighted by their values, as if the keys were replicated the number of times indicated by the corresponding value and then list pick used. The underlying metaphor for picking is that you&#39;re pulling colored marbles out a bag. (For &quot;picking with replacement&quot; see <a href="#method_roll">roll</a> instead). If <code>*</code> is passed as <code>$count</code>, or <code>$count</code> is greater than or equal to the <a href="#method_total">total</a> of the invocant, then <code>total</code> elements from the invocant are returned in a random sequence.</p>
<p>Note that each <code>pick</code> invocation maintains its own private state and has no effect on subsequent <code>pick</code> invocations.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs bacon bacon bacon&gt;;
say $breakfast.pick;                              # OUTPUT: «eggs␤»
say $breakfast.pick(2);                           # OUTPUT: «(eggs bacon)␤»

say $breakfast.total;                             # OUTPUT: «4␤»
say $breakfast.pick(*);                           # OUTPUT: «(bacon bacon bacon eggs)␤»</pre>
<h2 id="(Baggy)_method_pickpairs"><a href="/Documentable/integration-test/type/Baggy#method_pickpairs">(Baggy) method pickpairs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method pickpairs(Baggy:D: --&gt; Pair:D)
multi method pickpairs(Baggy:D: $count --&gt; Seq:D)</pre>
<p>Returns a <code>Pair</code> or a <code>Seq</code> of <code>Pair</code>s depending on the version of the method being invoked. Each <code>Pair</code> returned has an element of the invocant as its key and the element&#39;s weight as its value. The elements are &#39;picked&#39; without replacement. If <code>*</code> is passed as <code>$count</code>, or <code>$count</code> is greater than or equal to the number of <a href="#method_elems">elements</a> of the invocant, then all element/weight <code>Pair</code>s from the invocant are returned in a random sequence.</p>
<p>Note that each <code>pickpairs</code> invocation maintains its own private state and has no effect on subsequent <code>pickpairs</code> invocations.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs bacon bacon bacon&gt;;
say $breakfast.pickpairs;                         # OUTPUT: «eggs =&gt; 1␤»
say $breakfast.pickpairs(1);                      # OUTPUT: «(bacon =&gt; 3)␤»
say $breakfast.pickpairs(*);                      # OUTPUT: «(eggs =&gt; 1 bacon =&gt; 3)␤»</pre>
<h2 id="(Baggy)_method_roll"><a href="/Documentable/integration-test/type/Baggy#method_roll">(Baggy) method roll</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method roll(Baggy:D: --&gt; Any:D)
multi method roll(Baggy:D: $count --&gt; Seq:D)</pre>
<p>Like an ordinary list <a href="/Documentable/integration-test/type/List#routine_roll">roll</a>, but returns keys of the invocant weighted by their values, as if the keys were replicated the number of times indicated by the corresponding value and then list roll used. The underlying metaphor for rolling is that you&#39;re throwing <code>$count</code> dice that are independent of each other, which (in bag terms) is equivalent to picking a colored marble out your bag and then putting it back, and doing this <code>$count</code> times. In dice terms, the number of marbles corresponds to the number of sides, and the number of marbles of the same color corresponds to the number of sides with the same color. (For &quot;picking without replacement&quot; see <a href="#method_pick">pick</a> instead).</p>
<p>If <code>*</code> is passed to <code>$count</code>, returns a lazy, infinite sequence of randomly chosen elements from the invocant.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs bacon bacon bacon&gt;;
say $breakfast.roll;                                  # OUTPUT: «bacon␤»
say $breakfast.roll(3);                               # OUTPUT: «(bacon eggs bacon)␤»

my $random_dishes := $breakfast.roll(*);
say $random_dishes[^5];                               # OUTPUT: «(bacon eggs bacon bacon bacon)␤»</pre>
<h2 id="(Baggy)_method_pairs"><a href="/Documentable/integration-test/type/Baggy#method_pairs">(Baggy) method pairs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method pairs(Baggy:D: --&gt; Seq:D)</pre>
<p>Returns all elements and their respective weights as a <a href="/Documentable/integration-test/type/Seq">Seq</a> of <code>Pair</code>s where the key is the element itself and the value is the weight of that element.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;bacon eggs bacon&gt;;
my $seq = $breakfast.pairs;
say $seq.sort;                                    # OUTPUT: «(bacon =&gt; 2 eggs =&gt; 1)␤»</pre>
<h2 id="(Baggy)_method_antipairs"><a href="/Documentable/integration-test/type/Baggy#method_antipairs">(Baggy) method antipairs</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method antipairs(Baggy:D: --&gt; Seq:D)</pre>
<p>Returns all elements and their respective weights as a <a href="/Documentable/integration-test/type/Seq">Seq</a> of <a href="/Documentable/integration-test/type/Pair">Pairs</a>, where the element itself is the value and the weight of that element is the key, i.e. the opposite of method <a href="#method_pairs">pairs</a>.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;bacon eggs bacon&gt;;
my $seq = $breakfast.antipairs;
say $seq.sort;                                    # OUTPUT: «(1 =&gt; eggs 2 =&gt; bacon)␤»</pre>
<h2 id="(Baggy)_method_invert"><a href="/Documentable/integration-test/type/Baggy#method_invert">(Baggy) method invert</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method invert(Baggy:D: --&gt; Seq:D)</pre>
<p>Returns all elements and their respective weights as a <a href="/Documentable/integration-test/type/Seq">Seq</a> of <a href="/Documentable/integration-test/type/Pair">Pairs</a>, where the element itself is the value and the weight of that element is the key, i.e. the opposite of method <a href="#method_pairs">pairs</a>. Except for some esoteric cases, <code>invert</code> on a Baggy type returns the same result as <a href="#method_antipairs">antipairs</a>.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;bacon eggs bacon&gt;;
my $seq = $breakfast.invert;
say $seq.sort;                                    # OUTPUT: «(1 =&gt; eggs 2 =&gt; bacon)␤»</pre>
<h2 id="(Baggy)_method_classify-list"><a href="/Documentable/integration-test/type/Baggy#method_classify-list">(Baggy) method classify-list</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method classify-list(&amp;mapper, *@list --&gt; Baggy:D)
multi method classify-list(%mapper, *@list --&gt; Baggy:D)
multi method classify-list(@mapper, *@list --&gt; Baggy:D)</pre>
<p>Populates a <em>mutable</em> <a href="/Documentable/integration-test/type/Baggy"><code>Baggy</code></a> by classifying the possibly-empty <code>@list</code> of values using the given <code>mapper</code>. The <code>@list</code> cannot be lazy.</p>
<pre class="pod-block-code">say BagHash.new.classify-list: { $_ %% 2 ?? &#39;even&#39; !! &#39;odd&#39; }, ^10;
# OUTPUT: BagHash.new(even(5), odd(5))

my @mapper = &lt;zero one two three four five&gt;;
say MixHash.new.classify-list: @mapper, 1, 2, 3, 4, 4, 6;
# OUTPUT: MixHash.new((Any), two, three, four(2), one)</pre>
<p>The mapper can be a <a href="/Documentable/integration-test/type/Callable"><code>Callable</code></a> that takes a single argument, an <a href="/Documentable/integration-test/type/Associative"><code>Associative</code></a>, or an <a href="/Documentable/integration-test/type/Iterable"><code>Iterable</code></a>. With <a href="/Documentable/integration-test/type/Associative"><code>Associative</code></a> and an <a href="/Documentable/integration-test/type/Iterable"><code>Iterable</code></a> mappers, the values in the <code>@list</code> represent the key and index of the mapper&#39;s value respectively. A <a href="/Documentable/integration-test/type/Callable"><code>Callable</code></a> mapper will be executed once per each item in the <code>@list</code>, with that item as the argument and its return value will be used as the mapper&#39;s value.</p>
<p>The mapper&#39;s value is used as the key of the <a href="/Documentable/integration-test/type/Baggy"><code>Baggy</code></a> that will be incremented by <code>1</code>. See <a href="/Documentable/integration-test/routine/categorize-list"><code>.categorize-list</code></a> if you wish to classify an item into multiple categories at once.</p>
<p><strong>Note:</strong> unlike the <a href="/Documentable/integration-test/type/Hash"><code>Hash</code></a>&#39;s <code>.classify-list</code>, returning an <a href="/Documentable/integration-test/type/Iterable"><code>Iterable</code></a> mapper&#39;s value will throw, as <a href="/Documentable/integration-test/type/Baggy"><code>Baggy</code></a> types do not support nested classification. For the same reason, <a href="/Documentable/integration-test/type/Baggy"><code>Baggy</code></a>&#39;s <code>.classify-list</code> does not accept <code>:&amp;as</code> parameter.</p>
<h2 id="(Baggy)_method_categorize-list"><a href="/Documentable/integration-test/type/Baggy#method_categorize-list">(Baggy) method categorize-list</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">multi method categorize-list(&amp;mapper, *@list --&gt; Baggy:D)
multi method categorize-list(%mapper, *@list --&gt; Baggy:D)
multi method categorize-list(@mapper, *@list --&gt; Baggy:D)</pre>
<p>Populates a <em>mutable</em> <a href="/Documentable/integration-test/type/Baggy"><code>Baggy</code></a> by categorizing the possibly-empty <code>@list</code> of values using the given <code>mapper</code>. The <code>@list</code> cannot be lazy.</p>
<pre class="pod-block-code">say BagHash.new.categorize-list: {
    gather {
        take &#39;largish&#39; if $_ &gt; 5;
        take .is-prime ?? &#39;prime&#39; !! &#39;non-prime&#39;;
        take $_ %% 2   ?? &#39;even&#39;  !! &#39;odd&#39;;
    }
}, ^10;
# OUTPUT: BagHash.new(largish(4), even(5), non-prime(6), prime(4), odd(5))

my %mapper = :sugar&lt;sweet white&gt;, :lemon&lt;sour&gt;, :cake(&#39;sweet&#39;, &#39;is a lie&#39;);
say MixHash.new.categorize-list: %mapper, &lt;sugar lemon cake&gt;;
# OUTPUT: MixHash.new(is a lie, sour, white, sweet(2))</pre>
<p>The mapper can be a <a href="/Documentable/integration-test/type/Callable"><code>Callable</code></a> that takes a single argument, an <a href="/Documentable/integration-test/type/Associative"><code>Associative</code></a>, or an <a href="/Documentable/integration-test/type/Iterable"><code>Iterable</code></a>. With <a href="/Documentable/integration-test/type/Associative"><code>Associative</code></a> and an <a href="/Documentable/integration-test/type/Iterable"><code>Iterable</code></a> mappers, the values in the <code>@list</code> represent the key and index of the mapper&#39;s value respectively. A <a href="/Documentable/integration-test/type/Callable"><code>Callable</code></a> mapper will be executed once per each item in the <code>@list</code>, with that item as the argument and its return value will be used as the mapper&#39;s value.</p>
<p>The mapper&#39;s value is used as a possibly-empty list of keys of the <a href="/Documentable/integration-test/type/Baggy"><code>Baggy</code></a> that will be incremented by <code>1</code>.</p>
<p><strong>Note:</strong> unlike the <a href="/Documentable/integration-test/type/Hash"><code>Hash</code></a>&#39;s <code>.categorize-list</code>, returning a list of <a href="/Documentable/integration-test/type/Iterable"><code>Iterables</code></a> as mapper&#39;s value will throw, as <a href="/Documentable/integration-test/type/Baggy"><code>Baggy</code></a> types do not support nested categorization. For the same reason, <a href="/Documentable/integration-test/type/Baggy"><code>Baggy</code></a>&#39;s <code>.categorize-list</code> does not accept <code>:&amp;as</code> parameter.</p>
<h2 id="(Baggy)_method_keys"><a href="/Documentable/integration-test/type/Baggy#method_keys">(Baggy) method keys</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method keys(Baggy:D: --&gt; Seq:D)</pre>
<p>Returns a <code>Seq</code> of all keys in the <code>Baggy</code> object without taking their individual weights into account as opposed to <a href="#method_kxxv">kxxv</a>.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs spam spam spam&gt;;
say $breakfast.keys.sort;                        # OUTPUT: «(eggs spam)␤»

my $n = (&quot;a&quot; =&gt; 5, &quot;b&quot; =&gt; 2).BagHash;
say $n.keys.sort;                                # OUTPUT: «(a b)␤»</pre>
<h2 id="(Baggy)_method_values"><a href="/Documentable/integration-test/type/Baggy#method_values">(Baggy) method values</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method values(Baggy:D: --&gt; Seq:D)</pre>
<p>Returns a <code>Seq</code> of all values, i.e. weights, in the <code>Baggy</code> object.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs spam spam spam&gt;;
say $breakfast.values.sort;                      # OUTPUT: «(1 3)␤»

my $n = (&quot;a&quot; =&gt; 5, &quot;b&quot; =&gt; 2, &quot;a&quot; =&gt; 1).BagHash;
say $n.values.sort;                              # OUTPUT: «(2 6)␤»</pre>
<h2 id="(Baggy)_method_kv"><a href="/Documentable/integration-test/type/Baggy#method_kv">(Baggy) method kv</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method kv(Baggy:D: --&gt; Seq:D)</pre>
<p>Returns a <code>Seq</code> of keys and values interleaved.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs spam spam spam&gt;;
say $breakfast.kv;                                # OUTPUT: «(spam 3 eggs 1)␤»

my $n = (&quot;a&quot; =&gt; 5, &quot;b&quot; =&gt; 2, &quot;a&quot; =&gt; 1).BagHash;
say $n.kv;                                        # OUTPUT: «(a 6 b 2)␤»</pre>
<h2 id="(Baggy)_method_kxxv"><a href="/Documentable/integration-test/type/Baggy#method_kxxv">(Baggy) method kxxv</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method kxxv(Baggy:D: --&gt; Seq:D)</pre>
<p>Returns a <code>Seq</code> of the keys of the invocant, with each key multiplied by its weight. Note that <code>kxxv</code> only works for <code>Baggy</code> types which have integer weights, i.e. <a href="/Documentable/integration-test/type/Bag">Bag</a> and <a href="/Documentable/integration-test/type/BagHash">BagHash</a>.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;spam eggs spam spam bacon&gt;;
say $breakfast.kxxv.sort;                         # OUTPUT: «(bacon eggs spam spam spam)␤»

my $n = (&quot;a&quot; =&gt; 0, &quot;b&quot; =&gt; 1, &quot;b&quot; =&gt; 2).BagHash;
say $n.kxxv;                                      # OUTPUT: «(b b b)␤»</pre>
<h2 id="(Baggy)_method_elems"><a href="/Documentable/integration-test/type/Baggy#method_elems">(Baggy) method elems</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method elems(Baggy:D: --&gt; Int:D)</pre>
<p>Returns the number of elements in the <code>Baggy</code> object without taking the individual elements&#39; weight into account.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs spam spam spam&gt;;
say $breakfast.elems;                             # OUTPUT: «2␤»

my $n = (&quot;b&quot; =&gt; 9.4, &quot;b&quot; =&gt; 2).MixHash;
say $n.elems;                                     # OUTPUT: «1␤»</pre>
<h2 id="(Baggy)_method_total"><a href="/Documentable/integration-test/type/Baggy#method_total">(Baggy) method total</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method total(Baggy:D:)</pre>
<p>Returns the sum of weights for all elements in the <code>Baggy</code> object.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs spam spam bacon&gt;;
say $breakfast.total;                             # OUTPUT: «4␤»

my $n = (&quot;a&quot; =&gt; 5, &quot;b&quot; =&gt; 1, &quot;b&quot; =&gt; 2).BagHash;
say $n.total;                                     # OUTPUT: «8␤»</pre>
<h2 id="(Baggy)_method_default"><a href="/Documentable/integration-test/type/Baggy#method_default">(Baggy) method default</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method default(Baggy:D: --&gt; Int:D)</pre>
<p>Returns zero.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs bacon&gt;;
say $breakfast.default;                           # OUTPUT: «0␤»</pre>
<h2 id="(Baggy)_method_hash"><a href="/Documentable/integration-test/type/Baggy#method_hash">(Baggy) method hash</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method hash(Baggy:D: --&gt; Hash:D)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Hash">Hash</a> where the elements of the invocant are the keys and their respective weights the values.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs bacon bacon&gt;;
my $h = $breakfast.hash;
say $h.^name;                    # OUTPUT: «Hash[Any,Any]␤»
say $h;                          # OUTPUT: «{bacon =&gt; 2, eggs =&gt; 1}␤»</pre>
<h2 id="(Baggy)_method_Bool"><a href="/Documentable/integration-test/type/Baggy#method_Bool">(Baggy) method Bool</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Bool(Baggy:D: --&gt; Bool:D)</pre>
<p>Returns <code>True</code> if the invocant contains at least one element.</p>
<pre class="pod-block-code">my $breakfast = (&#39;eggs&#39; =&gt; 1).BagHash;
say $breakfast.Bool;                              # OUTPUT: «True   (since we have one element)␤»
$breakfast&lt;eggs&gt; = 0;                             # weight == 0 will lead to element removal
say $breakfast.Bool;                              # OUTPUT: «False␤»</pre>
<h2 id="(Baggy)_method_Set"><a href="/Documentable/integration-test/type/Baggy#method_Set">(Baggy) method Set</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method Set(--&gt; Set:D)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/Set">Set</a> whose elements are the <a href="#method_keys">keys</a> of the invocant.</p>
<pre class="pod-block-code">my $breakfast = (eggs =&gt; 2, bacon =&gt; 3).BagHash;
say $breakfast.Set;                               # OUTPUT: «set(bacon, eggs)␤»</pre>
<h2 id="(Baggy)_method_SetHash"><a href="/Documentable/integration-test/type/Baggy#method_SetHash">(Baggy) method SetHash</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method SetHash(--&gt; SetHash:D)</pre>
<p>Returns a <a href="/Documentable/integration-test/type/SetHash">SetHash</a> whose elements are the <a href="#method_keys">keys</a> of the invocant.</p>
<pre class="pod-block-code">my $breakfast = (eggs =&gt; 2, bacon =&gt; 3).BagHash;
my $sh = $breakfast.SetHash;
say $sh.^name;                            # OUTPUT: «SetHash␤»
say $sh.elems;                            # OUTPUT: «2␤»</pre>
<h2 id="(Baggy)_method_ACCEPTS"><a href="/Documentable/integration-test/type/Baggy#method_ACCEPTS">(Baggy) method ACCEPTS</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method ACCEPTS($other --&gt; Bool:D)</pre>
<p>Used in smartmatching if the right-hand side is a <code>Baggy</code>.</p>
<p>If the right-hand side is the type object, i.e. <code>Baggy</code>, the method returns <code>True</code> if <code>$other</code> <a href="/Documentable/integration-test/routine/does#class_Mu">does</a> <code>Baggy</code> otherwise <code>False</code> is returned.</p>
<p>If the right-hand side is a <code>Baggy</code> object, <code>True</code> is returned only if <code>$other</code> has the same elements, with the same weights, as the invocant.</p>
<pre class="pod-block-code">my $breakfast = bag &lt;eggs bacon&gt;;
say $breakfast ~~ Baggy;                            # OUTPUT: «True␤»
say $breakfast.does(Baggy);                         # OUTPUT: «True␤»

my $second-breakfast = (eggs =&gt; 1, bacon =&gt; 1).Mix;
say $breakfast ~~ $second-breakfast;                # OUTPUT: «True␤»

my $third-breakfast = (eggs =&gt; 1, bacon =&gt; 2).Bag;
say $second-breakfast ~~ $third-breakfast;          # OUTPUT: «False␤»</pre>
<h1 id="Routines_supplied_by_role_QuantHash"><a class="u" href="#___top" title="go to top of document">Routines supplied by role QuantHash</a></h1>
<p>Mix does role <a href="/Documentable/integration-test/type/QuantHash">QuantHash</a>, which provides the following routines:</p>
<h2 id="(QuantHash)_method_hash"><a href="/Documentable/integration-test/type/QuantHash#method_hash">(QuantHash) method hash</a></h2>
<pre class="pod-block-code">method hash()</pre>
<p>Coerces the <code>QuantHash</code> object to a <a href="/Documentable/integration-test/type/Hash">Hash</a> (by stringifying the objects for the keys) with the values of the hash limited to the same limitation as <code>QuantHash</code>, and returns that.</p>
<h2 id="(QuantHash)_method_Hash"><a href="/Documentable/integration-test/type/QuantHash#method_Hash">(QuantHash) method Hash</a></h2>
<pre class="pod-block-code">method Hash()</pre>
<p>Coerces the <code>QuantHash</code> object to a <a href="/Documentable/integration-test/type/Hash">Hash</a> (by stringifying the objects for the keys) without any limitations on the values, and returns that.</p>
<h2 id="(QuantHash)_method_of"><a href="/Documentable/integration-test/type/QuantHash#method_of">(QuantHash) method of</a></h2>
<pre class="pod-block-code">method of()</pre>
<p>Returns the type of value a value of this <code>QuantHash</code> may have. This is typically <a href="/Documentable/integration-test/type/Bool">Bool</a> for <a href="/Documentable/integration-test/type/Setty">Setty</a>, <a href="/Documentable/integration-test/type/UInt">UInt</a> for <a href="/Documentable/integration-test/type/Baggy">Baggy</a> or <a href="/Documentable/integration-test/type/Real">Real</a> for <a href="/Documentable/integration-test/type/Mixy">Mixy</a> roles.</p>
<h2 id="(QuantHash)_method_keyof"><a href="/Documentable/integration-test/type/QuantHash#method_keyof">(QuantHash) method keyof</a></h2>
<pre class="pod-block-code">method keyof()</pre>
<p>Returns the type of value a key of this subclass of <code>QuantHash</code> may have. This is typically <a href="/Documentable/integration-test/type/Mu">Mu</a>, which is also the default for punned QuantHashes.</p>
<h2 id="(QuantHash)_method_Setty"><a href="/Documentable/integration-test/type/QuantHash#method_Setty">(QuantHash) method Setty</a></h2>
<pre class="pod-block-code">method Setty(--&gt; Setty:D)</pre>
<p>Coerce the <code>QuantHash</code> object to the equivalent object that uses the <a href="/Documentable/integration-test/type/Setty">Setty</a> role. Note that for <a href="/Documentable/integration-test/type/Mixy">Mixy</a> type coercion items with negative values will be skipped.</p>
<pre class="pod-block-code">my %b is Bag = one =&gt; 1, two =&gt; 2;
say %b.Setty; # OUTPUT: «set(one two)␤»
my %m is Mix = one =&gt; 1, minus =&gt; -1;
say %m.Setty; # OUTPUT: «set(one)␤»</pre>
<h2 id="(QuantHash)_method_Baggy"><a href="/Documentable/integration-test/type/QuantHash#method_Baggy">(QuantHash) method Baggy</a></h2>
<pre class="pod-block-code">method Baggy(--&gt; Baggy:D)</pre>
<p>Coerce the <code>QuantHash</code> object to the equivalent object that uses the <a href="/Documentable/integration-test/type/Baggy">Baggy</a> role. Note that for <a href="/Documentable/integration-test/type/Mixy">Mixy</a> type coercion items with negative values will be skipped.</p>
<pre class="pod-block-code">my %s is Set = &lt;one two&gt;;
say %s.Baggy; # OUTPUT: «Bag(one, two)␤»
my %m is Mix = one =&gt; 1, minus =&gt; -1;
say %m.Baggy; # OUTPUT: «Bag(one)␤»</pre>
<h2 id="(QuantHash)_method_Mixy"><a href="/Documentable/integration-test/type/QuantHash#method_Mixy">(QuantHash) method Mixy</a></h2>
<pre class="pod-block-code">method Mixy(--&gt; Mixy:D)</pre>
<p>Coerce the <code>QuantHash</code> object to the equivalent object that uses the <a href="/Documentable/integration-test/type/Mixy">Mixy</a> role.</p>
<pre class="pod-block-code">my %s is Set = &lt;one two&gt;;
say %s.Mixy; # OUTPUT: «Mix(one, two)␤»
my %b is Bag = one =&gt; 1, two =&gt; 2;
say %b.Mixy; # OUTPUT: «Mix(one, two)␤»</pre>
<h1 id="Routines_supplied_by_role_Associative"><a class="u" href="#___top" title="go to top of document">Routines supplied by role Associative</a></h1>
<p>Mix does role <a href="/Documentable/integration-test/type/Associative">Associative</a>, which provides the following routines:</p>
<h2 id="(Associative)_method_of"><a href="/Documentable/integration-test/type/Associative#method_of">(Associative) method of</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method of()</pre>
<p><code>Associative</code> is actually a <a href="/Documentable/integration-test/language/objects#Parameterized_roles">parameterized role</a> which can use different classes for keys and values. As seen at the top of the document, by default it coerces to <code>Str</code> for the key and uses a very generic <code>Mu</code> for value.</p>
<pre class="pod-block-code">my %any-hash;
say %any-hash.of;#  OUTPUT: «(Mu)␤»</pre>
<p>The value is the first parameter you use when instantiating <code>Associative</code> with particular classes:</p>
<pre class="pod-block-code">class DateHash is Hash does Associative[Cool,DateTime] {};
my %date-hash := DateHash.new;
say %date-hash.of; # OUTPUT: «(Cool)␤»</pre>
<h2 id="(Associative)_method_keyof"><a href="/Documentable/integration-test/type/Associative#method_keyof">(Associative) method keyof</a></h2>
<p>Defined as:</p>
<pre class="pod-block-code">method keyof()</pre>
<p>Returns the parameterized key used for the Associative role, which is <code>Any</code> coerced to <code>Str</code> by default. This is the class used as second parameter when you use the parameterized version of Associative.</p>
<pre class="pod-block-code">my %any-hash;
%any-hash.keyof; #OUTPUT: «(Str(Any))␤»</pre>
<h2 id="(Associative)_method_AT-KEY"><a href="/Documentable/integration-test/type/Associative#method_AT-KEY">(Associative) method AT-KEY</a></h2>
<pre class="pod-block-code">method AT-KEY(\key)</pre>
<p>Should return the value / container at the given key.</p>
<h2 id="(Associative)_method_EXISTS-KEY"><a href="/Documentable/integration-test/type/Associative#method_EXISTS-KEY">(Associative) method EXISTS-KEY</a></h2>
<pre class="pod-block-code">method EXISTS-KEY(\key)</pre>
<p>Should return a <code>Bool</code> indicating whether the given key actually has a value.</p>
<h2 id="(Associative)_method_STORE"><a href="/Documentable/integration-test/type/Associative#method_STORE">(Associative) method STORE</a></h2>
<pre class="pod-block-code">method STORE(\values, :$initialize)</pre>
<p>This method should only be supplied if you want to support the:</p>
<pre class="pod-block-code">my %h is Foo = a =&gt; 42, b =&gt; 666;
</pre>
<p>syntax for binding your implementation of the <code>Associative</code> role.</p>
<p>Should accept the values to (re-)initialize the object with, which either could consist of <code>Pair</code>s, or separate key/value pairs. The optional named parameter will contain a <code>True</code> value when the method is called on the object for the first time. Should return the invocant.</p>

        </div>
    </div>

    

    <footer class="pretty-box yellow">
        <p>
            Generated from <a href="https://github.com/Raku/doc/blob/master/doc/Type/Mix.pod6">https://github.com/Raku/doc/blob/master/doc/Type/Mix.pod6</a>.
        </p>
        <p>
            This is a work in progress to document Raku (formerly known as Perl 6), and
            known to be incomplete.
        </p>
        <p>
            <a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md#reporting-bugs">
                Please report any issues
            </a>
            Your contribution is appreciated.
        </p>
        <p>
            This documentation is provided under the terms of the
            <a href="https://raw.githubusercontent.com/raku/doc/master/LICENSE">
                Artistic License 2.0
            </a>. The Camelia image is
            <a href="https://raw.githubusercontent.com/raku/mu/master/misc/camelia.txt">
                copyright © 2009 by Larry Wall.
            </a>
            <!-- CREDITS -->
            <!--External Link Image by Zapyon, CCA-SA 4.0. Derived from Wikimedia Foundation https://commons.wikimedia.org/wiki/File:External-link-04-bold-12x12.svg -->
        </p>
    </footer>

    <script type="text/javascript" src="/Documentable/integration-test/js/app.js?v=1"></script>
    <script type="text/javascript" src="/Documentable/integration-test/js/search.js?v=3"></script>
</body>
</html>

